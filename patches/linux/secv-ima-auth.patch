diff --git a/include/linux/optee_secv_smc.h b/include/linux/optee_secv_smc.h
new file mode 100644
index 0000000000000..64c2112dcf5be
--- /dev/null
+++ b/include/linux/optee_secv_smc.h
@@ -0,0 +1,17 @@
+/* include/linux/optee_secv_smc.h */
+#include <linux/arm-smccc.h>  
+
+#ifndef OPTEE_SMC_FAST_CALL_VAL
+#define OPTEE_SMC_FAST_CALL_VAL(func) \
+    ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, \
+                       ARM_SMCCC_SMC_32, \
+                       ARM_SMCCC_OWNER_TRUSTED_OS, \
+                       (func))
+#endif
+
+#define OPTEE_SMC_FUNCID_MID_TABLE   0x00FEU
+#define OPTEE_SMC_CALL_MID_TABLE \
+    OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_MID_TABLE)
+
+#define OPTEE_SMC_RETURN_OK                  0x0
+#define OPTEE_SMC_RETURN_UNKNOWN_FUNCTION    0xffffffffU
\ No newline at end of file
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 5f2a06fb36c1a..a4253d0b5e421 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -29,13 +29,17 @@
 #include <linux/evm.h>
 #include "ima.h"
 
-/*MODIFICATION*/
+#include <linux/mm.h> 
 #include <linux/types.h>   
 #include <linux/ktime.h>
 #include <linux/sched.h>
 #include <linux/sched/task.h>   
-#include <linux/ktime.h>
-extern int tee_send_exec_info(uint32_t pid, u8 *file_hash, u32 *can_ids, u32 num_ids);
+#include <linux/init.h>
+#include <linux/arm-smccc.h>
+#include <asm/cacheflush.h>
+#include <linux/optee_secv_smc.h> 
+
+#define SECV_MID_MAX   1024
 
 #ifdef CONFIG_IMA_APPRAISE
 int ima_appraise = IMA_APPRAISE_ENFORCE;
@@ -402,153 +406,117 @@ static int process_measurement(struct file *file, const struct cred *cred,
 			rc = mmap_violation_check(func, file, &pathbuf,
 						  &pathname, filename);}
 			
-			/*MODIFICATION : can id extraction + TEE session open*/	
 			if (func == BPRM_CHECK) {
-				ktime_t start, end;
-				s64 delta;
-			
-				start = ktime_get_ns();
-
-    			
-    			// Step 1: Check for appended CAN ID list size 
-				
+				if (system_state != SYSTEM_RUNNING || current->pid == 1) {
+					goto skip_tee;
+				}
 
+    			/* Check for appended MID list size */
 				loff_t fsize = i_size_read(inode);
-    			if (fsize < sizeof(uint32_t)) {
-        		pr_err("[IMA debug] File too small to contain CAN ID list\n");
-        		goto skip_tee;
+    			if (fsize < sizeof(__le32)) {
+        			goto skip_tee;
     			}
-
-				
-    			//pr_info("[IMA debug] 2. Starting CAN ID list extraction\n");
     			
 				file->f_pos = 0;
-    			uint32_t can_id_size = 0;
+    			uint32_t mid_size = 0;
     			loff_t offset = fsize - sizeof(uint32_t);
-				//pr_info("[IMA debug] Reading CAN ID size from offset: %lld, file size: %lld\n", offset, fsize);
-				ssize_t r = kernel_read(file, &can_id_size, sizeof(uint32_t), &offset);
-				can_id_size = le32_to_cpu(can_id_size);
+				ssize_t r = kernel_read(file, &mid_size, sizeof(uint32_t), &offset);
+				mid_size = le32_to_cpu(mid_size);
 
     			if (r != sizeof(uint32_t)) {
-        			pr_err("[IMA debug] Failed to read CAN ID size\n");
+        			pr_err("[IMA debug] Failed to read MID size\n");
         			goto skip_tee;
     			}
 
-    			char *can_id_data = kmalloc(can_id_size, GFP_KERNEL);
-    			if (!can_id_data) {
-        			pr_err("[IMA debug] Failed to alloc can_id_data\n");
+				if (mid_size == 0 || mid_size > SECV_MID_MAX || (12 + mid_size) > fsize){
+					pr_err("[IMA debug] No MID detected\n");
+    				goto skip_tee;
+				}
+
+    			char *mid_data = kmalloc(mid_size, GFP_KERNEL);
+    			if (!mid_data) {
+        			pr_err("[IMA debug] Failed to alloc mid_data\n");
         			goto skip_tee;
     			}
 
-    			offset = fsize - sizeof(uint32_t) - can_id_size;
-				r = kernel_read(file, can_id_data, can_id_size, &offset);
-    			if (r != can_id_size) {
-        			pr_err("[IMA debug] Failed to read CAN ID data\n");
-        			kfree(can_id_data);
+    			offset = fsize - sizeof(uint32_t) - mid_size;
+				r = kernel_read(file, mid_data, mid_size, &offset);
+    			if (r != mid_size) {
+        			pr_err("[IMA debug] Failed to read MID data\n");
+        			kfree(mid_data);
         			goto skip_tee;
     			}
 
-				if(can_id_size == 0){
-					//pr_info("[IMA debug] No CAN ID detected\n");
-					kfree(can_id_data);
+				if(mid_size == 0){
+					//pr_info("[IMA debug] No MID detected\n");
+					kfree(mid_data);
         			goto skip_tee;
 				}
-			
-    			//pr_info("[IMA debug] 3. CAN ID list extraction completed (%u bytes)\n", can_id_size);
-
-    			// Step 2: Prepare hash of the full merged file 
-				offset = 0;
-				ssize_t read_len;
-				uint8_t *file_buf = kmalloc(fsize, GFP_KERNEL);
-				if (!file_buf) {
-    				pr_err("[IMA debug] Failed to alloc file_buf for hash\n");
-    				kfree(can_id_data);
-    				goto skip_tee;
-				}
 
-				read_len = kernel_read(file, file_buf, fsize, &offset);
-				if (read_len != fsize) {
-    				pr_err("[IMA debug] Failed to read full merged file (read=%zd)\n", read_len);
-    				kfree(file_buf);
-    				kfree(can_id_data);
+				if (!iint->ima_hash || !(iint->flags & IMA_COLLECTED)) {
+    				//pr_info("[IMA] hash not collected yet; skip TEE\n");
+    				kfree(mid_data);
     				goto skip_tee;
 				}
 
-				u8 merged_hash[SHA256_DIGEST_SIZE];
-				struct crypto_shash *tfm = crypto_alloc_shash("sha256", 0, 0);
-				if (IS_ERR(tfm)) {
-    				pr_err("[IMA debug] Failed to alloc sha256 tfm\n");
-    				kfree(file_buf);
-    				kfree(can_id_data);
-    				goto skip_tee;
-				}
+				int algo = iint->ima_hash->algo;
+    			size_t dlen = hash_digest_size[algo];
+    			u8 digest[IMA_MAX_DIGEST_SIZE];
 
-				struct shash_desc *desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
-				if (!desc) {
-					pr_err("[IMA debug] Failed to alloc shash_desc\n");
-					crypto_free_shash(tfm);
-					kfree(file_buf);
-					kfree(can_id_data);
-					goto skip_tee;
-				}
+    			if (dlen != 32) {
+        			//pr_info("[IMA] Digest size=%zu for algo=%d (expected 32)\n", dlen, algo);
+        			kfree(mid_data);
+        			goto skip_tee;
+    			}
 
-				desc->tfm = tfm;
-
-				if (crypto_shash_init(desc) ||
-				crypto_shash_update(desc, file_buf, fsize) ||
-				crypto_shash_final(desc, merged_hash)) {
-				pr_err("[IMA debug] SHA256 computation failed\n");
-				kfree(desc);
-				crypto_free_shash(tfm);
-				kfree(file_buf);
-				kfree(can_id_data);
-				goto skip_tee;
-				}			
-
-				kfree(desc);
-				crypto_free_shash(tfm);
-				kfree(file_buf);
-
-				/*
-				// Step 3: Prepare Secure World message 
-    			struct exec_info_msg {
+    			memcpy(digest, iint->ima_hash->digest, dlen);
+
+   			 	//pr_info("[IMA] prepare sw msg struct\n");
+
+				/* Prepare Secure World message */
+    			struct __packed exec_info_msg {
         			uint32_t pid;
-        			u8 file_hash[32];
-        			u32 can_id_len;
-        			uint32_t can_ids[];
+        			uint8_t file_hash[32];   /* hash digest of the file */
+        			uint32_t num_ids;        /* MID size (e.g., can message id, port id, etc/) */
+        			uint32_t mids[];    /* actual encrypted MIDs */
     			};
 				
-    			size_t msg_len = sizeof(struct exec_info_msg) + can_id_size;
-    			struct exec_info_msg *msg = kmalloc(msg_len, GFP_KERNEL);
-    			if (!msg) {
-        			pr_err("[IMA debug] Failed to alloc exec_info_msg\n");
-        			kfree(can_id_data);
-        			goto skip_tee;
-    			}
-					
-				msg->pid = current->pid;
-				msg->can_id_len = can_id_size;
-    			memcpy(msg->file_hash, merged_hash, 32);
-    			memcpy(msg->can_ids, can_id_data, can_id_size);
-
-    			//pr_info("[IMA debug] 5. TEE session opened and exec_info_msg prepared for pid=%d\n", msg->pid);
-
-    			// Step 4: Send to TEE 
-    			tee_send_exec_info(msg->pid, msg->file_hash, (u32 *)msg->can_ids, msg->can_id_len / sizeof(u32));
-
-    			kfree(msg);
-    			kfree(can_id_data);
-			*/
-				//end = ktime_get_ns();
-    			//delta = end - start;
-				//pr_info(">>> [measure] IMA executionoverhead: %lld ns\n", delta);
-
-			skip_tee:
-    			;
-				} 
+				uint32_t num_ids = mid_size / sizeof(uint32_t);
+				size_t total = sizeof(struct exec_info_msg) + num_ids * sizeof(uint32_t);
+
+				struct exec_info_msg *buf = kmalloc(total, GFP_KERNEL);
+				if (!buf) goto skip_tee;
+
+				buf->pid = current->pid;
+				memcpy(buf->file_hash, digest, 32);
+				buf->num_ids = num_ids;
+				memcpy(buf->mids, mid_data, num_ids * sizeof(uint32_t));
+
+				dcache_clean_poc((unsigned long)buf, (unsigned long)buf + total);
+
+				phys_addr_t pa = virt_to_phys(buf);
+				uint32_t pa_lo = (uint32_t)(pa & 0xffffffffu);
+				uint32_t pa_hi = (uint32_t)(pa >> 32);
+
+				struct arm_smccc_res res;
+
+    			arm_smccc_smc((unsigned long)OPTEE_SMC_CALL_MID_TABLE, /* a0: SMC32 fid */
+				(unsigned long)pa_lo,                    /* a1: PA low */
+				(unsigned long)pa_hi,                    /* a2: PA high */
+				(unsigned long)((uint32_t)total),             /* a3: len */
+				0,0,0,0, &res);
+
+    			if (res.a0 != OPTEE_SMC_RETURN_OK)
+					pr_err("[IMA fastcall] OP-TEE ret=0x%llx\n", res.a0);
+
+    			memzero_explicit(buf, total);
+				kfree(buf);
+
+				skip_tee:
+				;
+			} 
 		rc = ima_check_blacklist(iint, modsig, pcr);
-		/*MODIFICATION ENDS HERE*/
-		
 	}
 
 	
@@ -1315,7 +1283,7 @@ static int __init init_ima(void)
 
 	if (error && strcmp(hash_algo_name[ima_hash_algo],
 			    CONFIG_IMA_DEFAULT_HASH) != 0) {
-		pr_info("Allocating %s failed, going to use default hash algorithm %s\n",
+		pr_debug("Allocating %s failed, going to use default hash algorithm %s\n",
 			hash_algo_name[ima_hash_algo], CONFIG_IMA_DEFAULT_HASH);
 		hash_setup_done = 0;
 		hash_setup(CONFIG_IMA_DEFAULT_HASH);
@@ -1380,4 +1348,4 @@ DEFINE_LSM(ima) = {
 	.blobs = &ima_blob_sizes,
 };
 
-late_initcall(init_ima);	/* Start IMA after the TPM is available */
+late_initcall(init_ima);	/* Start IMA after the TPM is available */
\ No newline at end of file
