diff --git a/drivers/tee/optee/Makefile b/drivers/tee/optee/Makefile
index a6eff388d300..586539b8141b 100644
--- a/drivers/tee/optee/Makefile
+++ b/drivers/tee/optee/Makefile
@@ -8,6 +8,7 @@ optee-objs += supp.o
 optee-objs += device.o
 optee-objs += smc_abi.o
 optee-objs += ffa_abi.o
+optee-objs += tee_send_exec_info.o
 
 # for tracing framework to find optee_trace.h
 CFLAGS_smc_abi.o := -I$(src)
diff --git a/drivers/tee/optee/tee_send_exec_info.c b/drivers/tee/optee/tee_send_exec_info.c
new file mode 100644
index 000000000000..78cb9fd9f1d7
--- /dev/null
+++ b/drivers/tee/optee/tee_send_exec_info.c
@@ -0,0 +1,102 @@
+#include <linux/tee_drv.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/uuid.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include "../tee_private.h"
+#include <linux/ktime.h>
+
+#define PTA_CAN_ID_UUID \
+    UUID_INIT(0x12345678, 0x1111, 0x1234, \
+                0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0)
+
+static uuid_t can_id_uuid __maybe_unused = PTA_CAN_ID_UUID;
+
+#define PTA_CMD_REGISTER_EXEC_INFO  0
+#define TEEC_SUCCESS    0x00000000
+
+static int match_any(struct tee_ioctl_version_data *vers, const void *data)
+{
+    return true;
+}
+
+int tee_send_exec_info(uint32_t pid, u8 *file_hash, u32 *can_ids, u32 num_ids)
+{
+    struct tee_context *ctx;
+    struct tee_shm *shm = NULL;
+    struct tee_ioctl_open_session_arg sess_arg = {0};
+    struct tee_ioctl_invoke_arg inv_arg = {0};
+    struct tee_param param[1] = {0};
+    size_t shm_size;
+    u8 *shm_buf;
+    int rc;
+
+    /*1. Open TEE Context with TEE driver */
+    ctx = tee_client_open_context(NULL, match_any, NULL, NULL);
+    if(IS_ERR(ctx)) {
+        return PTR_ERR(ctx);
+    }
+
+    if(!ctx->teedev || !ctx->teedev->desc || !ctx->teedev->desc->ops) {
+        rc = -ENODEV;
+        goto out_ctx;
+    }
+
+    /* 2. Open session with PTA */
+    export_uuid(sess_arg.uuid, &can_id_uuid);
+    sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+    sess_arg.num_params = 0;
+
+    rc = tee_client_open_session(ctx, &sess_arg, NULL);
+    if(rc < 0 || sess_arg.ret != TEEC_SUCCESS) {
+        rc = rc < 0? rc : -EINVAL;
+        goto out_ctx;
+    }
+
+    /*3. Allocate shared memory */
+    shm_size = sizeof(uint32_t) + 32 + sizeof(u32) + num_ids * sizeof(u32);
+    shm = tee_shm_alloc_kernel_buf(ctx, shm_size);
+    if(IS_ERR(shm)) {
+        rc = PTR_ERR(shm);
+        goto out_sess;
+    }
+
+    shm_buf = tee_shm_get_va(shm, 0);
+    if(IS_ERR(shm_buf)) {
+        rc = PTR_ERR(shm_buf);
+        goto out_shm;
+    }
+
+    /*4. Copy data into shared memory */
+    u8 *p = shm_buf;
+    memcpy(p, &pid, sizeof(uint32_t));
+    p += sizeof(uint32_t);
+    memcpy(p, file_hash, 32);
+    p += 32;
+    memcpy(p, can_ids, num_ids * sizeof(u32));
+
+    /* 5. Setup TEE parameters */
+    inv_arg.func = PTA_CMD_REGISTER_EXEC_INFO;
+    inv_arg.session = sess_arg.session;
+    inv_arg.num_params = 1;
+
+    param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+    param[0].u.memref.shm = shm;
+    param[0].u.memref.shm_offs = 0;
+    param[0].u.memref.size = shm_size;
+
+    /* 6. Invoke PTA function */
+    rc = tee_client_invoke_func(ctx, &inv_arg, param);
+    if(rc < 0 || inv_arg.ret != TEEC_SUCCESS) {
+        rc = rc < 0? rc : -EINVAL;
+    } 
+
+out_shm:
+    tee_shm_free(shm);
+out_sess:
+    tee_client_close_session(ctx, sess_arg.session);
+out_ctx:
+    tee_client_close_context(ctx);
+    return rc;
+}
\ No newline at end of file
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 27ea19fb1f54..f38c95a46e75 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -21,6 +21,112 @@
 #include <linux/lsm_hooks.h>
 #include "integrity.h"
 
+
+/* SECV Modification */
+#include <linux/binfmts.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <crypto/hash.h>
+#include <linux/mm.h>
+
+extern int extract_canid_and_hash_from_file(struct file *file, u8 *can_ids_out, u8 *hash_out, u32 *can_id_len_out);
+extern void tee_send_exec_info(uint32_t pid, u8 *hash, u32 *can_ids, u32 num_ids);
+
+int extract_canid_and_hash_from_file(struct file *file, u8 *can_ids_out, u8 *hash_out, u32 *can_id_len_out)
+{
+	long fsize = i_size_read(file_inode(file));
+	if(fsize < sizeof(u32))
+		return -EINVAL;
+	
+	loff_t offset = fsize - sizeof(u32);
+	u32 can_id_size;
+	ssize_t r = kernel_read(file, &can_id_size, sizeof(u32), &offset);
+	if(r != sizeof(u32))
+		return -EIO;
+	
+	can_id_size = __le32_to_cpu(can_id_size);
+	if(can_id_size == 0 || can_id_size > 256)
+		return -EINVAL;
+
+	offset = fsize - sizeof(u32) - can_id_size;
+	r = kernel_read(file, can_ids_out, can_id_size, &offset);
+	if(r != can_id_size)
+		return -EIO;
+
+	*can_id_len_out = can_id_size;
+
+	/* compute the hash */
+	u8 *buf = kmalloc(fsize, GFP_KERNEL);
+	if(!buf) 
+		return -ENOMEM;
+	
+	offset = 0;
+	r = kernel_read(file, buf, fsize, &offset);
+	if(r != fsize) {
+		kfree(buf);
+		return -EIO;
+	}
+
+	struct crypto_shash *tfm = crypto_alloc_shash("sha256",0,0);
+	if(IS_ERR(tfm)) {
+		kfree(buf); 
+		return PTR_ERR(tfm);
+	}
+
+	struct shash_desc *desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if(!desc) {
+		crypto_free_shash(tfm);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	desc->tfm = tfm;
+
+	crypto_shash_init(desc);
+	crypto_shash_update(desc, buf, fsize);
+	crypto_shash_final(desc, hash_out);
+
+	kfree(desc);
+	crypto_free_shash(tfm);
+	kfree(buf);
+
+	return 0;
+}
+
+
+static int my_task_alloc(struct task_struct *task, unsigned long clone_flags) 
+{
+	struct file *exec_file;
+	u8 can_ids[256];
+	u8 hash[32];
+	u32 can_id_len = 0;
+	int ret;
+
+	if(!current || !current->mm)
+		return 0;
+
+	exec_file = get_mm_exe_file(current->mm);
+	if(!exec_file)
+		return 0;
+
+	ret = extract_canid_and_hash_from_file(exec_file, can_ids, hash, &can_id_len);
+	fput(exec_file);
+
+	if (ret != 0 || can_id_len == 0) 
+		return 0;
+
+	u32 num_ids = can_id_len / sizeof(u32);
+
+	tee_send_exec_info(task->pid, hash, (u32 *)can_ids, num_ids);
+
+	return 0;
+}
+
+static struct security_hook_list secv_integrity_hooks[] __ro_after_init = {
+	LSM_HOOK_INIT(task_alloc, my_task_alloc),
+};
+/*End of SECV Modification*/
+
 static struct rb_root integrity_iint_tree = RB_ROOT;
 static DEFINE_RWLOCK(integrity_iint_lock);
 static struct kmem_cache *iint_cache __read_mostly;
@@ -198,6 +304,7 @@ static int __init integrity_iintcache_init(void)
 	iint_cache =
 	    kmem_cache_create("iint_cache", sizeof(struct integrity_iint_cache),
 			      0, SLAB_PANIC, iint_init_once);
+	security_add_hooks(secv_integrity_hooks, sizeof(secv_integrity_hooks), "integrity");
 	return 0;
 }
 DEFINE_LSM(integrity) = {
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index cc1217ac2c6f..6f65f9c0b23c 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -27,6 +27,13 @@
 #include <linux/fs.h>
 #include <linux/iversion.h>
 
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+#include <linux/sched/task.h>
+
+extern int tee_send_exec_info(uint32_t pid, u8 *file_hash, u32 *can_ids, u32 num_ids);
+
 #include "ima.h"
 
 #ifdef CONFIG_IMA_APPRAISE
@@ -376,9 +383,123 @@ static int process_measurement(struct file *file, const struct cred *cred,
 						      xattr_len, modsig);
 			inode_unlock(inode);
 		}
-		if (!rc)
+		if (!rc){
 			rc = mmap_violation_check(func, file, &pathbuf,
 						  &pathname, filename);
+
+			/*SeCV MODIFICATION: can id extraction + TEE session open */
+			if(func == BPRM_CHECK) {
+				/* 1. Check for appended CAN ID list size */
+				long fsize = i_size_read(inode);
+				if(fsize < sizeof(uint32_t)) {
+					goto skip_tee;
+				}
+
+				file->f_pos = 0;
+				uint32_t can_id_size = 0;
+				long offset = fsize - sizeof(uint32_t);
+				ssize_t r = kernel_read(file, &can_id_size, sizeof(uint32_t), &offset);
+				can_id_size = __le32_to_cpu(can_id_size);
+
+				if(r != sizeof(uint32_t)) {
+					goto skip_tee;
+				}
+
+				char *can_id_data = kmalloc(can_id_size, GFP_KERNEL);
+				if(!can_id_data) {
+					goto skip_tee;
+				}
+
+				offset = fsize - sizeof(uint32_t) - can_id_size;
+				r = kernel_read(file, can_id_data, can_id_size, &offset);
+				if(r != can_id_size) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				if(can_id_size == 0) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				/* 2. Prepare hash of the fully merged file */
+				offset = 0;
+				ssize_t read_len;
+				uint8_t *file_buf = kmalloc(fsize, GFP_KERNEL);
+				if(!file_buf) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				read_len = kernel_read(file, file_buf, fsize, &offset);
+				if(read_len != fsize) {
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				u8 merged_hash[SHA256_DIGEST_SIZE];
+				struct crypto_shash *tfm = crypto_alloc_shash("sha256",0,0);
+				if(IS_ERR(tfm)) {
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				struct shash_desc *desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+				if(!desc) {
+					crypto_free_shash(tfm);
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				desc->tfm = tfm;
+
+				if(crypto_shash_init(desc) ||
+					crypto_shash_update(desc, file_buf, fsize) || 
+						crypto_shash_final(desc, merged_hash)) {
+					kfree(desc);
+					crypto_free_shash(tfm);
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				kfree(desc);
+				crypto_free_shash(tfm);
+				kfree(file_buf);
+
+				/* 3. Prepare Secure World message */
+				struct exec_info_msg {
+					uint32_t pid;
+					u8 file_hash[32];
+					u32 can_id_len;
+					uint32_t can_ids[];
+				};
+
+				size_t msg_len = sizeof(struct exec_info_msg) + can_id_size;
+				struct exec_info_msg *msg = kmalloc(msg_len, GFP_KERNEL);
+				if(!msg) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				msg->pid = current->pid;
+				msg->can_id_len = can_id_size;
+				memcpy(msg->file_hash, merged_hash, 32);
+				memcpy(msg->can_ids, can_id_data, can_id_size);
+
+				/* 4. Send to TEE */
+				tee_send_exec_info(msg->pid, msg->file_hash, (u32 *)msg->can_ids, msg->can_id_len / sizeof(u32));
+
+				kfree(msg);
+				kfree(can_id_data);
+				skip_tee:
+					;
+				/* end of SECV Modification */
+			}
+		}			
 	}
 	if (action & IMA_AUDIT)
 		ima_audit_measurement(iint, pathname);
