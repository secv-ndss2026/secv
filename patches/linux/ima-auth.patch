diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index 8c05a7f374d8..03e9c8d58270 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -69,6 +69,7 @@ static inline void __cpu_die(unsigned int cpu) { }
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
 extern void arch_send_wakeup_ipi_mask(const struct cpumask *mask);
+extern void arch_set_secv_ipi_handler(void(*handler)(void*));
 
 extern int register_ipi_completion(struct completion *completion, int cpu);
 
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 3431c0553f45..14831cf35ff5 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -65,6 +65,7 @@ enum ipi_msg_type {
 	IPI_CPU_STOP,
 	IPI_IRQ_WORK,
 	IPI_COMPLETION,
+	IPI_SECV,
 	NR_IPI,
 	/*
 	 * CPU_BACKTRACE is special and not included in NR_IPI
@@ -539,6 +540,7 @@ static const char *ipi_types[NR_IPI] __tracepoint_string = {
 	[IPI_CPU_STOP]		= "CPU stop interrupts",
 	[IPI_IRQ_WORK]		= "IRQ work interrupts",
 	[IPI_COMPLETION]	= "completion interrupts",
+	[IPI_SECV]			= "SECV interrupt from SSMe",
 };
 
 static void smp_cross_call(const struct cpumask *target, unsigned int ipinr);
diff --git a/arch/arm64/boot/dts/freescale/s32g.dtsi b/arch/arm64/boot/dts/freescale/s32g.dtsi
index b81ae52f59d0..d81469ee1a17 100644
--- a/arch/arm64/boot/dts/freescale/s32g.dtsi
+++ b/arch/arm64/boot/dts/freescale/s32g.dtsi
@@ -46,6 +46,13 @@ pfe_reserved_bdr: pfebufs@835e0000 {
 			/* 128 KB */
 			reg = <0 0x835e0000 0 0x20000>;
 		};
+
+		secv_shmem: sorhta_shmem@E0000000 {
+			compatible = "shared-dma-pool";
+			reg = <0 0xE0000000 0 0x3000000>;
+			no-map;
+			//reusable
+		};
 		/* ends 0x83600000 */
 	};
 
diff --git a/arch/arm64/include/asm/smp.h b/arch/arm64/include/asm/smp.h
index 9b31e6d0da17..892dcad51bd3 100644
--- a/arch/arm64/include/asm/smp.h
+++ b/arch/arm64/include/asm/smp.h
@@ -87,6 +87,7 @@ extern void secondary_entry(void);
 
 extern void arch_send_call_function_single_ipi(int cpu);
 extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);
+extern void arch_set_secv_ipi_handler(void(*handler)(void*));
 
 #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
 extern void arch_send_wakeup_ipi_mask(const struct cpumask *mask);
diff --git a/arch/arm64/kernel/hilps/idc_backup.S b/arch/arm64/kernel/hilps/idc_backup.S
new file mode 100644
index 000000000000..bba276cff102
--- /dev/null
+++ b/arch/arm64/kernel/hilps/idc_backup.S
@@ -0,0 +1,83 @@
+/*
+Inner Domain Call (IDC)
+ */
+.section .text
+.global IDC
+.type IDC, %function
+.extern InnerDomain_handler
+.extern InnerDomain_stack
+
+IDC:
+    /* The entry gate */
+    mrs x5, DAIF
+    stp x30, x5, [sp, #-16]!
+    mrs x6, tcr_el1
+    str x6, [sp, #-8]!
+    msr DAIFset, 0x3            // Disable interrupts
+
+1:
+// ---- Setup inner domain VA window & TTBR select ----
+    msr x5, tcr_el1             // Read the current TCR
+    bic x5, x5, #0x00020000     // Only (1 << 17) to 0, original: and x5, x5, #0xfffffffffffdffff     // TCR.T1SZ = 25 => 1101_ffff (turn 17th bit to 0) 
+    orr x5, x5, #0x400000       // TCR.A1 = 1: use TTBR1 => 0100_0_0000((turn 22th bit to 1))
+    msr tcr_el1, x5             // Configure TCR
+    isb                         // Instruction synchronization barrier
+
+// ---- Check configured TCR value ----
+    mov x6, #0xc03f             // A mask to check the value of TCR
+    mov x7, #0x1b               // TCR.T1SZ = 25 (39-bit address space) => answer -> x7= 01_1011
+    movk x6, #0xc07f, lsl #16   // TCR.T0SZ = 27 (37-bit address space) => T1SZ + low 16bit(TG0,SH0,ORGN0,IRGN0,EPD0,RES0,T0SZ)
+    // total x6 = 0xc07f_c03f (1100_0000_0111_1111_1100_0000_0011_1111)
+    movk x7, #0x8059, lsl #16       // TCR.TG1 = 0b10 (4KB page size)
+   // total x7 = 0x8059_001b (1000_0000_0101_1001_0000_0000_0001_1011)
+    //MODIFICATION
+    mrs x5, tcr_el1
+    and x5, x5, x6              // TCR.TG0 = 0b00 (4KB page size)
+    cmp x5, x7                  // TCR.A1 = 1 (Use TTBR1.ASID)
+    b.ne 1b                     // If not correct, configure TCR again
+
+    mrs x6, mpidr_el1           // Get number of the current core [0-n]
+    ubfx x5, x6, #8, #4         //cluster level
+    and x6, x6, #0xf            //core level
+    add x6, x6, x5, lsl #2      // original code: orr x6, x6, x5, lsl #2
+    add x6, x6, #1              // Add 1 to the core number
+    adrp x5, InnerDomain_stack        // Get the base address of the inner domain stack
+    add    x5, x5, #:lo12:InnerDomain_stack //MODIFICATION
+    add x5, x5, x6, lsl #12           // Get the inner domain stack of the current core
+    mov x6, sp                  // Get the outer domain stack
+    mov sp, x5                  // Switch to the inner domain stack
+    str x6, [sp, #-8]!          // Save the outer domain stack
+
+    adrp x5, InnerDomain_handler      // Get the address of the inner domain handler, doing inner domain thing somehow
+    add x5, x5, :lo12:InnerDomain_handler
+    blr x5                      // Jump to the inner domain handler
+
+    /* The exit gate*/
+    /* 
+    ldr x6, [sp], #8            // Restore the outer domain stack
+    mov sp, x6                  // Switch to the outer domain stack
+
+//2:
+.global exit_gate
+exit_gate:
+    mrs x5, tcr_el1             // Read the current TCR
+    bic   x5, x5, #0x00400000   // original: and x5, x5, #0xffffffffffbfffff     // Clear A1 -> ?(Set TCR.T1SZ to 27) => 10(22th=A1)11_f_ffff [wrong comment]
+    orr x5, x5, #0x20000        // Set TCR.T1SZ to 27-> ?Clear TCR.A1 => 2 [wrong comment]
+    msr tcr_el1, x5             // Configure TCR
+
+    mov x6, #0xc03f             // Check the value of TCR
+    mov x7, #0x1b               // TCR.T1SZ = 27 (37-bit address space)
+    movk x6, #0xc07f, lsl #16       // TCR.T0SZ = 27 (37-bit address space)
+    movk x7, #0x801b, lsl #16       // TCR.TG1 = 0b10 (4KB page size)
+    and x5, x5, x6              // TCR.TG0 = 0b00 (4KB page size)
+    cmp x5, x7                  // TCR.A1 = 0 (Use TTBR0.ASID)
+    b.ne exit_gate              //b.ne 2b                 // If not correct, configure TCR again
+    */
+
+    ldr   x6, [sp], #8
+    msr   tcr_el1, x6
+   
+    ldp x30, x5, [sp], #16      // Restore interrupt status
+    msr DAIF, x5                // Enable interrupts
+    isb                         // Instruction synchronization barrier
+    ret                         // Return to the outer domain 
\ No newline at end of file
diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c
index 14365ef84244..47c749cfb9cd 100644
--- a/arch/arm64/kernel/smp.c
+++ b/arch/arm64/kernel/smp.c
@@ -73,6 +73,7 @@ enum ipi_msg_type {
 	IPI_TIMER,
 	IPI_IRQ_WORK,
 	IPI_WAKEUP,
+	IPI_SECV,
 	NR_IPI
 };
 
@@ -799,6 +800,13 @@ void arch_send_call_function_single_ipi(int cpu)
 	smp_cross_call(cpumask_of(cpu), IPI_CALL_FUNC);
 }
 
+void(*secv_ipi_handler)(void*) = NULL;
+
+void arch_set_secv_ipi_handler(void(*handler)(void*))
+{
+	secv_ipi_handler = handler;
+}
+
 #ifdef CONFIG_ARM64_ACPI_PARKING_PROTOCOL
 void arch_send_wakeup_ipi_mask(const struct cpumask *mask)
 {
@@ -886,6 +894,13 @@ static void do_handle_IPI(int ipinr)
 			unreachable();
 		}
 		break;
+	case IPI_SECV:
+		if(secv_ipi_handler != NULL) {
+			secv_ipi_handler(NULL);
+		} else {
+			pr_crit("CPU%u: SECV IPI handler not set 0x%x\n", cpu, ipinr);
+		}
+		break;
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
 	case IPI_TIMER:
diff --git a/drivers/net/can/flexcan/flexcan-core.c b/drivers/net/can/flexcan/flexcan-core.c
index 2800e4ef6cd0..33c70c8fa539 100644
--- a/drivers/net/can/flexcan/flexcan-core.c
+++ b/drivers/net/can/flexcan/flexcan-core.c
@@ -34,6 +34,22 @@
 
 #include "flexcan.h"
 
+// SECV: Includes
+#include <linux/of_reserved_mem.h>
+#include <linux/of_address.h>
+#include <linux/dma-mapping.h>
+#include <linux/timer.h>
+#include <linux/smp.h>
+#include "secv_flexcan.h"
+
+void __iomem *secv_shmem_virt_addr = NULL;
+struct secv_flexcan_priv *secv_flexcan_privs[NUM_FLEXCAN_INTERFACES] = { NULL };
+struct secv_tx_ring_buffers *secv_flexcan_tx_rings[NUM_FLEXCAN_INTERFACES] = { NULL };
+struct secv_rx_ring_buffers *secv_flexcan_rx_rings[NUM_FLEXCAN_INTERFACES] = { NULL };
+static struct secv_tx_ring_buffers secv_local_flexcan_tx_rings[NUM_FLEXCAN_INTERFACES];
+static struct timer_list secv_tx_timer;
+
+
 #define DRV_NAME			"flexcan"
 
 /* 8 for RX fifo and 2 error handling */
@@ -550,6 +566,11 @@ static u32 flexcan_get_timestamp(struct flexcan_priv *priv)
 	return timestamp << 16;
 }
 
+// SECV: handle an IPI/SGI from the SSMe
+static void secv_ipi_handler(void* dev_id) {
+	// Handle the SGI from SSMe.
+}
+
 static struct flexcan_mb __iomem *flexcan_get_mb(const struct flexcan_priv *priv,
 						 u8 mb_index)
 {
@@ -845,6 +866,8 @@ static int flexcan_get_berr_counter(const struct net_device *dev,
 	return err;
 }
 
+
+
 static netdev_tx_t flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	const struct flexcan_priv *priv = netdev_priv(dev);
@@ -854,10 +877,34 @@ static netdev_tx_t flexcan_start_xmit(struct sk_buff *skb, struct net_device *de
 	u32 ctrl = FLEXCAN_MB_CODE_TX_DATA | ((can_fd_len2dlc(cfd->len)) << 16);
 	int i;
 
+	// SECV:
+	u32 interface_index;
+	struct secv_flexcan_priv *secv_priv;
+	struct secv_tx_ring_buffers *tx_ring;
+	struct tx_mb* mb;
+	u32 tx_index;
+	u32 actual_send;
+
 	if (can_dev_dropped_skb(dev, skb))
 		return NETDEV_TX_OK;
 
-	netif_stop_queue(dev);
+	// SECV: Get the interface index
+	interface_index = get_interface_index(priv->regs);
+	if(interface_index != 0 && interface_index != 1) {
+		netdev_err(dev, "Invalid interface index: %u\n", interface_index);
+		return NETDEV_TX_OK;
+	}
+
+	// SECV: transmission, do we have space in the TX ring buffer?
+	tx_ring = &secv_local_flexcan_tx_rings[interface_index];
+	tx_index = tx_ring->count;
+	tx_ring->count++;
+
+	actual_send = 0;
+	if (tx_ring->count == NUM_TX_BUFFERS) {
+		actual_send = 1;
+		netif_stop_queue(dev);
+	}
 
 	if (cfd->can_id & CAN_EFF_FLAG) {
 		can_id = cfd->can_id & CAN_EFF_MASK;
@@ -876,24 +923,35 @@ static netdev_tx_t flexcan_start_xmit(struct sk_buff *skb, struct net_device *de
 			ctrl |= FLEXCAN_MB_CNT_BRS;
 	}
 
-	for (i = 0; i < cfd->len; i += sizeof(u32)) {
-		data = be32_to_cpup((__be32 *)&cfd->data[i]);
-		priv->write(data, &priv->tx_mb->data[i / sizeof(u32)]);
-	}
+	mb = &tx_ring->mbs[tx_ring->count];
+	mb->can_id = can_id;
+	mb->can_ctrl = ctrl;
+	memcpy(mb->data, cfd->data, sizeof(*cfd));
+
+	// for (i = 0; i < cfd->len; i += sizeof(u32)) {
+	// 	data = be32_to_cpup((__be32 *)&cfd->data[i]);
+	// 	priv->write(data, &priv->tx_mb->data[i / sizeof(u32)]);
+	// }
 
 	can_put_echo_skb(skb, dev, 0, 0);
 
-	priv->write(can_id, &priv->tx_mb->can_id);
-	priv->write(ctrl, &priv->tx_mb->can_ctrl);
+	// priv->write(can_id, &priv->tx_mb->can_id);
+	// priv->write(ctrl, &priv->tx_mb->can_ctrl);
 
 	/* Errata ERR005829 step8:
 	 * Write twice INACTIVE(0x8) code to first MB.
 	 */
-	priv->write(FLEXCAN_MB_CODE_TX_INACTIVE,
-		    &priv->tx_mb_reserved->can_ctrl);
-	priv->write(FLEXCAN_MB_CODE_TX_INACTIVE,
-		    &priv->tx_mb_reserved->can_ctrl);
-
+	// priv->write(FLEXCAN_MB_CODE_TX_INACTIVE,
+	// 	    &priv->tx_mb_reserved->can_ctrl);
+	// priv->write(FLEXCAN_MB_CODE_TX_INACTIVE,
+	// 	    &priv->tx_mb_reserved->can_ctrl);
+	if(actual_send) {
+		// SECV: trigger transmission
+		memcpy((void*)tx_ring, (void*)&secv_local_flexcan_tx_rings[interface_index], sizeof(struct secv_tx_ring_buffers));
+		secv_flexcan_trigger_tx(interface_index);
+	}else if(tx_index == 0) {
+		mod_timer(&secv_tx_timer, jiffies + msecs_to_jiffies(5));
+	}
 	return NETDEV_TX_OK;
 }
 
@@ -1837,6 +1895,11 @@ static int flexcan_open(struct net_device *dev)
 	int err;
 	u32 i, j, last, irq_array_len = ARRAY_SIZE(flexcan_irq_handlers);
 
+	// SECV: initialize nsec for secv_priv 
+	struct secv_flexcan_priv *secv_priv;
+	u32 interface_index;
+
+
 	if ((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) &&
 	    (priv->can.ctrlmode & CAN_CTRLMODE_FD)) {
 		netdev_err(dev, "Three Samples mode and CAN-FD mode can't be used together\n");
@@ -1877,6 +1940,26 @@ static int flexcan_open(struct net_device *dev)
 				}
 			}
 
+	interface_index = get_interface_index(priv->regs);
+	if(interface_index == 0 || interface_index == 1) {
+		secv_priv = secv_flexcan_privs[interface_index];
+		secv_priv->regs = (struct flexcan_regs *)translate_el1(priv->regs);
+		secv_priv->tx_mb = (struct flexcan_mb *)translate_el1(priv->tx_mb);
+		secv_priv->tx_mb_reserved = (struct flexcan_mb *)translate_el1(priv->tx_mb_reserved);
+		secv_priv->interface_index = interface_index;
+		secv_priv->tx_mb_idx = priv->tx_mb_idx;
+		secv_priv->mb_count = priv->mb_count;
+		secv_priv->mb_size = priv->mb_size;
+		secv_priv->rx_mask = priv->rx_mask;
+		secv_priv->tx_mask = priv->tx_mask;
+		secv_priv->quirks = priv->devtype_data.quirks;
+		secv_priv->offload_mb_first = priv->offload.mb_first;
+		secv_priv->offload_mb_last = priv->offload.mb_last;
+		secv_priv->reg_ctrl_default = priv->reg_ctrl_default;
+		secv_priv->nsec_initialized = 1;
+		memset((void*)&secv_local_flexcan_tx_rings[interface_index], 0, sizeof(struct secv_tx_ring_buffers));
+	}
+
 	flexcan_chip_interrupts_enable(dev);
 
 	netif_start_queue(dev);
@@ -2187,6 +2270,10 @@ static unsigned long get_per_clk_rate(struct clk *clk)
 	return rate;
 }
 
+static void secv_tx_timer_callback(struct timer_list *t) {
+	// TODO: send the frames we have now.
+}
+
 static int flexcan_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id;
@@ -2203,6 +2290,54 @@ static int flexcan_probe(struct platform_device *pdev)
 	u32 i, clock_freq = 0;
 	bool named_irqs;
 
+	// SECV
+	struct device_node *rmem_node;
+	struct reserved_mem *rmem;
+	phys_addr_t secv_shmem_phys_addr;
+	size_t secv_shmem_size;
+
+	// SECV shared memory mapping
+	if(secv_shmem_virt_addr == NULL) {
+		rmem_node = of_find_node_by_path("/reserved-memory/sorhta_shmem@E0000000");
+		if (!rmem_node) {
+			dev_err(&pdev->dev, "No secv-shmem node found in DT\n");
+			return -ENODEV;
+		}
+		
+
+		rmem = of_reserved_mem_lookup(rmem_node);
+		of_node_put(rmem_node);
+		if (!rmem) {
+			dev_err(&pdev->dev, "No reserved memory found for secv-shmem\n");
+			return -ENODEV;
+		}
+
+		secv_shmem_phys_addr = rmem->base;
+		secv_shmem_size = rmem->size;
+
+		secv_shmem_virt_addr = ioremap(secv_shmem_phys_addr, secv_shmem_size);
+		if (!secv_shmem_virt_addr) {
+			dev_err(&pdev->dev, "Failed to ioremap secv-shmem\n");
+			return -ENOMEM;
+		}
+
+		secv_flexcan_privs[0] = (struct secv_flexcan_priv *)((char*)secv_shmem_virt_addr + SORHTA_PRIV0_BASE_OFF);
+		secv_flexcan_privs[1] = (struct secv_flexcan_priv *)((char*)secv_shmem_virt_addr + SORHTA_PRIV1_BASE_OFF);
+
+		secv_flexcan_rx_rings[0] = (struct secv_rx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_RX_SHMEM_BASE0_OFF);
+		secv_flexcan_rx_rings[1] = (struct secv_rx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_RX_SHMEM_BASE1_OFF);
+
+		secv_flexcan_tx_rings[0] = (struct secv_tx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_TX_SHMEM_BASE0_OFF);
+		secv_flexcan_tx_rings[1] = (struct secv_tx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_TX_SHMEM_BASE1_OFF);
+
+		timer_setup(&secv_tx_timer, secv_tx_timer_callback, 0);
+
+		arch_set_secv_ipi_handler(secv_ipi_handler);
+
+		dev_info(&pdev->dev, "SECV shared memory mapped at phys: 0x%pa, virt: %p, size: %zu\n",
+			 &secv_shmem_phys_addr, secv_shmem_virt_addr, secv_shmem_size);
+	}
+
 	reg_xceiver = devm_regulator_get_optional(&pdev->dev, "xceiver");
 	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
diff --git a/drivers/net/can/flexcan/secv_flexcan.c b/drivers/net/can/flexcan/secv_flexcan.c
new file mode 100644
index 000000000000..bc8d23286afd
--- /dev/null
+++ b/drivers/net/can/flexcan/secv_flexcan.c
@@ -0,0 +1,5 @@
+#include "secv_flexcan.h"
+
+
+
+
diff --git a/drivers/net/can/flexcan/secv_flexcan.h b/drivers/net/can/flexcan/secv_flexcan.h
new file mode 100644
index 000000000000..684d0b186034
--- /dev/null
+++ b/drivers/net/can/flexcan/secv_flexcan.h
@@ -0,0 +1,82 @@
+#ifndef SECV_FLEXCAN_H
+#define SECV_FLEXCAN_H
+
+#include "secv_tee.h"
+#include "flexcan.h"
+
+#define NUM_FLEXCAN_INTERFACES      2
+#define RX_RING_SIZE                512
+#define FRAME_COUNT_PER_MB          16
+#define NUM_TX_BUFFERS              8
+#define NUM_RX_BUFFERS              FRAME_COUNT_PER_MB * NUM_TX_BUFFERS
+#define MAX_MBS                     128
+
+#define SORHTA_PRIV0_BASE_OFF           (PAGE_SIZE)
+#define SORHTA_PRIV1_BASE_OFF           (PAGE_SIZE * 2)
+
+#define SORHTA_FLEXCAN_RX_SHMEM_BASE0_OFF	0x2000000UL
+#define SORHTA_FLEXCAN_RX_SHMEM_BASE1_OFF	0x2800000UL
+#define SORHTA_FLEXCAN_TX_SHMEM_BASE0_OFF	0x1000000UL
+#define SORHTA_FLEXCAN_TX_SHMEM_BASE1_OFF	0x1800000UL
+
+#define S32_FLEXCAN0_BASE_ADDR          0x401B4000UL
+#define S32_FLEXCAN1_BASE_ADDR          0x401BE000UL
+#define S32_FLEXCAN_SIZE                0xA000UL
+
+struct secv_flexcan_priv {
+    struct flexcan_regs *regs;
+    struct flexcan_mb   *tx_mb;
+    struct flexcan_mb   *tx_mb_reserved;
+    uint8_t interface_index;
+    uint8_t nsec_initialized;
+    uint8_t sec_initialized;
+    uint8_t tx_mb_idx;
+    uint8_t mb_count;
+    uint8_t mb_size;
+    uint64_t rx_mask;
+    uint64_t tx_mask;
+    uint32_t reg_ctrl_default;
+    uint32_t quirks;
+    uint32_t offload_mb_first;
+    uint32_t offload_mb_last;
+};
+
+
+struct rx_mb {
+    uint32_t can_ctrl;
+    uint32_t can_id;
+    struct canfd_frame data;
+};
+
+struct tx_mb {
+    uint32_t can_ctrl;
+    uint32_t can_ctrl_tx;
+    uint32_t can_id;
+    struct canfd_frame *data;
+};
+
+struct secv_tx_ring_buffers {
+    struct tx_mb mbs[NUM_TX_BUFFERS];
+    size_t count;
+};
+
+
+struct secv_rx_ring_buffers {
+    struct rx_mb mbs[NUM_RX_BUFFERS];
+    size_t count;
+};
+
+static inline u32 get_interface_index(void __iomem *regs)
+{
+    char* p = (char*)translate_el1((u64)regs);
+    if(p < (char*)S32_FLEXCAN1_BASE_ADDR && p >= (char*)S32_FLEXCAN0_BASE_ADDR  ) {
+        return 0;
+    } else if(p >= (char*)S32_FLEXCAN1_BASE_ADDR && p < (char*)(S32_FLEXCAN1_BASE_ADDR + S32_FLEXCAN_SIZE) ) {
+        return 1;
+    } 
+
+    return 0xFFFFFFFF;
+}
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/net/can/flexcan/secv_tee.h b/drivers/net/can/flexcan/secv_tee.h
new file mode 100644
index 000000000000..c0588be0947d
--- /dev/null
+++ b/drivers/net/can/flexcan/secv_tee.h
@@ -0,0 +1,129 @@
+#ifndef SECV_TEE_H
+#define SECV_TEE_H
+
+#include <linux/arm-smccc.h>
+#include <linux/atomic.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#define MASK_47_TO_12   0x0000FFFFFFFFF000ULL
+#define MASK_11_TO_0    0x000000000000FFFULL
+
+#define SECV_SHMEM_BASE 0xE2000000ULL
+#define SECV_SHMEM_SIZE 0x2000ULL
+
+/* Map a NW virtual address to a physical address */
+__attribute__((always_inline)) static inline u64 translate_el1(u64 virt_addr)
+{
+    u64 phys_addr = virt_addr;
+    asm("AT S1E1R, %[a];"
+        "MRS %[a], PAR_EL1;"
+        : [a] "+r"(phys_addr));
+
+    if((1 & phys_addr)) {
+        //printk(KERN_ALERT "EL1 translation fault %llx for addr 0xllx\n", phys_addr, virt_addr);
+        return phys_addr;
+    }
+    phys_addr = (MASK_47_TO_12 & phys_addr) + (MASK_11_TO_0 & virt_addr);
+    return phys_addr;
+}
+
+
+#define OPTEE_SMC_STD_CALL_VAL(func_num) \
+            ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32, \
+                ARM_SMCCC_OWNER_TRUSTED_OS, (func_num))
+
+#define OPTEE_SMC_FAST_CALL_VAL(func_num) \
+            ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL, ARM_SMCCC_SMC_32, \
+                ARM_SMCCC_OWNER_TRUSTED_OS, (func_num))
+
+
+#define OPTEE_FUNCID_CAN_NOTIFY     0xF1
+#define OPTEE_FUNCID_CAN_READ_BE    0xF2
+#define OPTEE_FUNCID_CAN_WRITE_BE   0xF3
+#define OPTEE_FUNCID_CAN_READ_LE    0xF4
+#define OPTEE_FUNCID_CAN_WRITE_LE   0xF5
+#define OPTEE_FUNCID_CAN_TRIGGER_TX 0xF6
+
+#define OPTEE_SMC_FUNCID_CAN_NOTIFY OPTEE_FUNCID_CAN_NOTIFY
+#define OPTEE_SMC_CALL_CAN_NOTIFY   \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_NOTIFY)
+
+#define OPTEE_SMC_FUNCID_CAN_READ_BE    OPTEE_FUNCID_CAN_READ_BE
+#define OPTEE_SMC_CALL_CAN_READ_BE  \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_READ_BE)
+
+#define OPTEE_SMC_FUNCID_CAN_WRITE_BE   OPTEE_FUNCID_CAN_WRITE_BE
+#define OPTEE_SMC_CALL_CAN_WRITE_BE \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_WRITE_BE)
+
+#define OPTEE_SMC_FUNCID_CAN_READ_LE    OPTEE_FUNCID_CAN_READ_LE
+#define OPTEE_SMC_CALL_CAN_READ_LE  \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_READ_LE)
+
+#define OPTEE_SMC_FUNCID_CAN_WRITE_LE    OPTEE_FUNCID_CAN_WRITE_LE
+#define OPTEE_SMC_CALL_CAN_WRITE_LE  \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_WRITE_LE)
+
+#define OPTEE_SMC_FUNCID_CAN_TRIGGER_TX    OPTEE_FUNCID_CAN_TRIGGER_TX
+#define OPTEE_SMC_CALL_CAN_TRIGGER_TX  \
+                OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_TRIGGER_TX)
+
+__attribute__((always_inline)) static inline uint32_t 
+secv_read_le(void* __iomem addr)
+{
+    struct arm_smccc_res res;
+    u64 address;
+    address = translate_el1((u64)addr);
+
+    arm_smccc_smc(OPTEE_SMC_CALL_CAN_READ_LE, // a0
+        address, // a1
+        0,  // a2
+        0,  // a3
+        0,  // a4
+        0,  // a5
+        0,  // a6
+        0,  // a7
+        &res
+    );
+    return (uint32_t)res.a0;
+}
+
+
+__attribute__((always_inline)) static inline void 
+secv_write_le(uint32_t val, void* __iomem addr)
+{
+    struct arm_smccc_res res;
+    u64 address;
+    address = translate_el1((u64)addr);
+
+    arm_smccc_smc(OPTEE_SMC_CALL_CAN_WRITE_LE, // a0
+        address, // a1
+        val,  // a2
+        0,  // a3
+        0,  // a4
+        0,  // a5
+        0,  // a6
+        0,  // a7
+        &res
+    );
+}
+
+__attribute__((always_inline)) static inline void
+secv_flexcan_trigger_tx(uint32_t interface_index)
+{
+    struct arm_smccc_res res;
+
+    arm_smccc_smc(OPTEE_SMC_CALL_CAN_TRIGGER_TX, // a0
+        interface_index, // a1
+        0,  // a2
+        0,  // a3
+        0,  // a4
+        0,  // a5
+        0,  // a6
+        0,  // a7
+        &res
+    );
+}
+
+#endif
\ No newline at end of file
diff --git a/drivers/tee/optee/Makefile b/drivers/tee/optee/Makefile
index a6eff388d300..586539b8141b 100644
--- a/drivers/tee/optee/Makefile
+++ b/drivers/tee/optee/Makefile
@@ -8,6 +8,7 @@ optee-objs += supp.o
 optee-objs += device.o
 optee-objs += smc_abi.o
 optee-objs += ffa_abi.o
+optee-objs += tee_send_exec_info.o
 
 # for tracing framework to find optee_trace.h
 CFLAGS_smc_abi.o := -I$(src)
diff --git a/drivers/tee/optee/tee_send_exec_info.c b/drivers/tee/optee/tee_send_exec_info.c
new file mode 100644
index 000000000000..78cb9fd9f1d7
--- /dev/null
+++ b/drivers/tee/optee/tee_send_exec_info.c
@@ -0,0 +1,102 @@
+#include <linux/tee_drv.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/uuid.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include "../tee_private.h"
+#include <linux/ktime.h>
+
+#define PTA_CAN_ID_UUID \
+    UUID_INIT(0x12345678, 0x1111, 0x1234, \
+                0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0)
+
+static uuid_t can_id_uuid __maybe_unused = PTA_CAN_ID_UUID;
+
+#define PTA_CMD_REGISTER_EXEC_INFO  0
+#define TEEC_SUCCESS    0x00000000
+
+static int match_any(struct tee_ioctl_version_data *vers, const void *data)
+{
+    return true;
+}
+
+int tee_send_exec_info(uint32_t pid, u8 *file_hash, u32 *can_ids, u32 num_ids)
+{
+    struct tee_context *ctx;
+    struct tee_shm *shm = NULL;
+    struct tee_ioctl_open_session_arg sess_arg = {0};
+    struct tee_ioctl_invoke_arg inv_arg = {0};
+    struct tee_param param[1] = {0};
+    size_t shm_size;
+    u8 *shm_buf;
+    int rc;
+
+    /*1. Open TEE Context with TEE driver */
+    ctx = tee_client_open_context(NULL, match_any, NULL, NULL);
+    if(IS_ERR(ctx)) {
+        return PTR_ERR(ctx);
+    }
+
+    if(!ctx->teedev || !ctx->teedev->desc || !ctx->teedev->desc->ops) {
+        rc = -ENODEV;
+        goto out_ctx;
+    }
+
+    /* 2. Open session with PTA */
+    export_uuid(sess_arg.uuid, &can_id_uuid);
+    sess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;
+    sess_arg.num_params = 0;
+
+    rc = tee_client_open_session(ctx, &sess_arg, NULL);
+    if(rc < 0 || sess_arg.ret != TEEC_SUCCESS) {
+        rc = rc < 0? rc : -EINVAL;
+        goto out_ctx;
+    }
+
+    /*3. Allocate shared memory */
+    shm_size = sizeof(uint32_t) + 32 + sizeof(u32) + num_ids * sizeof(u32);
+    shm = tee_shm_alloc_kernel_buf(ctx, shm_size);
+    if(IS_ERR(shm)) {
+        rc = PTR_ERR(shm);
+        goto out_sess;
+    }
+
+    shm_buf = tee_shm_get_va(shm, 0);
+    if(IS_ERR(shm_buf)) {
+        rc = PTR_ERR(shm_buf);
+        goto out_shm;
+    }
+
+    /*4. Copy data into shared memory */
+    u8 *p = shm_buf;
+    memcpy(p, &pid, sizeof(uint32_t));
+    p += sizeof(uint32_t);
+    memcpy(p, file_hash, 32);
+    p += 32;
+    memcpy(p, can_ids, num_ids * sizeof(u32));
+
+    /* 5. Setup TEE parameters */
+    inv_arg.func = PTA_CMD_REGISTER_EXEC_INFO;
+    inv_arg.session = sess_arg.session;
+    inv_arg.num_params = 1;
+
+    param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+    param[0].u.memref.shm = shm;
+    param[0].u.memref.shm_offs = 0;
+    param[0].u.memref.size = shm_size;
+
+    /* 6. Invoke PTA function */
+    rc = tee_client_invoke_func(ctx, &inv_arg, param);
+    if(rc < 0 || inv_arg.ret != TEEC_SUCCESS) {
+        rc = rc < 0? rc : -EINVAL;
+    } 
+
+out_shm:
+    tee_shm_free(shm);
+out_sess:
+    tee_client_close_session(ctx, sess_arg.session);
+out_ctx:
+    tee_client_close_context(ctx);
+    return rc;
+}
\ No newline at end of file
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 27ea19fb1f54..f38c95a46e75 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -21,6 +21,112 @@
 #include <linux/lsm_hooks.h>
 #include "integrity.h"
 
+
+/* SECV Modification */
+#include <linux/binfmts.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <crypto/hash.h>
+#include <linux/mm.h>
+
+extern int extract_canid_and_hash_from_file(struct file *file, u8 *can_ids_out, u8 *hash_out, u32 *can_id_len_out);
+extern void tee_send_exec_info(uint32_t pid, u8 *hash, u32 *can_ids, u32 num_ids);
+
+int extract_canid_and_hash_from_file(struct file *file, u8 *can_ids_out, u8 *hash_out, u32 *can_id_len_out)
+{
+	long fsize = i_size_read(file_inode(file));
+	if(fsize < sizeof(u32))
+		return -EINVAL;
+	
+	loff_t offset = fsize - sizeof(u32);
+	u32 can_id_size;
+	ssize_t r = kernel_read(file, &can_id_size, sizeof(u32), &offset);
+	if(r != sizeof(u32))
+		return -EIO;
+	
+	can_id_size = __le32_to_cpu(can_id_size);
+	if(can_id_size == 0 || can_id_size > 256)
+		return -EINVAL;
+
+	offset = fsize - sizeof(u32) - can_id_size;
+	r = kernel_read(file, can_ids_out, can_id_size, &offset);
+	if(r != can_id_size)
+		return -EIO;
+
+	*can_id_len_out = can_id_size;
+
+	/* compute the hash */
+	u8 *buf = kmalloc(fsize, GFP_KERNEL);
+	if(!buf) 
+		return -ENOMEM;
+	
+	offset = 0;
+	r = kernel_read(file, buf, fsize, &offset);
+	if(r != fsize) {
+		kfree(buf);
+		return -EIO;
+	}
+
+	struct crypto_shash *tfm = crypto_alloc_shash("sha256",0,0);
+	if(IS_ERR(tfm)) {
+		kfree(buf); 
+		return PTR_ERR(tfm);
+	}
+
+	struct shash_desc *desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if(!desc) {
+		crypto_free_shash(tfm);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	desc->tfm = tfm;
+
+	crypto_shash_init(desc);
+	crypto_shash_update(desc, buf, fsize);
+	crypto_shash_final(desc, hash_out);
+
+	kfree(desc);
+	crypto_free_shash(tfm);
+	kfree(buf);
+
+	return 0;
+}
+
+
+static int my_task_alloc(struct task_struct *task, unsigned long clone_flags) 
+{
+	struct file *exec_file;
+	u8 can_ids[256];
+	u8 hash[32];
+	u32 can_id_len = 0;
+	int ret;
+
+	if(!current || !current->mm)
+		return 0;
+
+	exec_file = get_mm_exe_file(current->mm);
+	if(!exec_file)
+		return 0;
+
+	ret = extract_canid_and_hash_from_file(exec_file, can_ids, hash, &can_id_len);
+	fput(exec_file);
+
+	if (ret != 0 || can_id_len == 0) 
+		return 0;
+
+	u32 num_ids = can_id_len / sizeof(u32);
+
+	tee_send_exec_info(task->pid, hash, (u32 *)can_ids, num_ids);
+
+	return 0;
+}
+
+static struct security_hook_list secv_integrity_hooks[] __ro_after_init = {
+	LSM_HOOK_INIT(task_alloc, my_task_alloc),
+};
+/*End of SECV Modification*/
+
 static struct rb_root integrity_iint_tree = RB_ROOT;
 static DEFINE_RWLOCK(integrity_iint_lock);
 static struct kmem_cache *iint_cache __read_mostly;
@@ -198,6 +304,7 @@ static int __init integrity_iintcache_init(void)
 	iint_cache =
 	    kmem_cache_create("iint_cache", sizeof(struct integrity_iint_cache),
 			      0, SLAB_PANIC, iint_init_once);
+	security_add_hooks(secv_integrity_hooks, sizeof(secv_integrity_hooks), "integrity");
 	return 0;
 }
 DEFINE_LSM(integrity) = {
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index cc1217ac2c6f..6f65f9c0b23c 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -27,6 +27,13 @@
 #include <linux/fs.h>
 #include <linux/iversion.h>
 
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+#include <linux/sched/task.h>
+
+extern int tee_send_exec_info(uint32_t pid, u8 *file_hash, u32 *can_ids, u32 num_ids);
+
 #include "ima.h"
 
 #ifdef CONFIG_IMA_APPRAISE
@@ -376,9 +383,123 @@ static int process_measurement(struct file *file, const struct cred *cred,
 						      xattr_len, modsig);
 			inode_unlock(inode);
 		}
-		if (!rc)
+		if (!rc){
 			rc = mmap_violation_check(func, file, &pathbuf,
 						  &pathname, filename);
+
+			/*SeCV MODIFICATION: can id extraction + TEE session open */
+			if(func == BPRM_CHECK) {
+				/* 1. Check for appended CAN ID list size */
+				long fsize = i_size_read(inode);
+				if(fsize < sizeof(uint32_t)) {
+					goto skip_tee;
+				}
+
+				file->f_pos = 0;
+				uint32_t can_id_size = 0;
+				long offset = fsize - sizeof(uint32_t);
+				ssize_t r = kernel_read(file, &can_id_size, sizeof(uint32_t), &offset);
+				can_id_size = __le32_to_cpu(can_id_size);
+
+				if(r != sizeof(uint32_t)) {
+					goto skip_tee;
+				}
+
+				char *can_id_data = kmalloc(can_id_size, GFP_KERNEL);
+				if(!can_id_data) {
+					goto skip_tee;
+				}
+
+				offset = fsize - sizeof(uint32_t) - can_id_size;
+				r = kernel_read(file, can_id_data, can_id_size, &offset);
+				if(r != can_id_size) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				if(can_id_size == 0) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				/* 2. Prepare hash of the fully merged file */
+				offset = 0;
+				ssize_t read_len;
+				uint8_t *file_buf = kmalloc(fsize, GFP_KERNEL);
+				if(!file_buf) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				read_len = kernel_read(file, file_buf, fsize, &offset);
+				if(read_len != fsize) {
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				u8 merged_hash[SHA256_DIGEST_SIZE];
+				struct crypto_shash *tfm = crypto_alloc_shash("sha256",0,0);
+				if(IS_ERR(tfm)) {
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				struct shash_desc *desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+				if(!desc) {
+					crypto_free_shash(tfm);
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				desc->tfm = tfm;
+
+				if(crypto_shash_init(desc) ||
+					crypto_shash_update(desc, file_buf, fsize) || 
+						crypto_shash_final(desc, merged_hash)) {
+					kfree(desc);
+					crypto_free_shash(tfm);
+					kfree(file_buf);
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				kfree(desc);
+				crypto_free_shash(tfm);
+				kfree(file_buf);
+
+				/* 3. Prepare Secure World message */
+				struct exec_info_msg {
+					uint32_t pid;
+					u8 file_hash[32];
+					u32 can_id_len;
+					uint32_t can_ids[];
+				};
+
+				size_t msg_len = sizeof(struct exec_info_msg) + can_id_size;
+				struct exec_info_msg *msg = kmalloc(msg_len, GFP_KERNEL);
+				if(!msg) {
+					kfree(can_id_data);
+					goto skip_tee;
+				}
+
+				msg->pid = current->pid;
+				msg->can_id_len = can_id_size;
+				memcpy(msg->file_hash, merged_hash, 32);
+				memcpy(msg->can_ids, can_id_data, can_id_size);
+
+				/* 4. Send to TEE */
+				tee_send_exec_info(msg->pid, msg->file_hash, (u32 *)msg->can_ids, msg->can_id_len / sizeof(u32));
+
+				kfree(msg);
+				kfree(can_id_data);
+				skip_tee:
+					;
+				/* end of SECV Modification */
+			}
+		}			
 	}
 	if (action & IMA_AUDIT)
 		ima_audit_measurement(iint, pathname);
