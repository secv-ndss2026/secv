diff --git a/core/arch/arm/include/sm/optee_smc.h b/core/arch/arm/include/sm/optee_smc.h
index 04a3839a2..38f9280e5 100644
--- a/core/arch/arm/include/sm/optee_smc.h
+++ b/core/arch/arm/include/sm/optee_smc.h
@@ -132,6 +132,74 @@
 #define OPTEE_SMC_CALL_GET_OS_REVISION \
 	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_OS_REVISION)
 
+
+#define OPTEE_FUNCID_CAN_NOTIFY 0x00F1U
+#define OPTEE_FUNCID_READ_BE	0x00F2U
+#define OPTEE_FUNCID_WRITE_BE	0x00F3U
+#define OPTEE_FUNCID_READ_LE	0x00F4U
+#define OPTEE_FUNCID_WRITE_LE	0x00F5U
+#define OPTEE_FUNCID_XMIT		0x00F6U
+#define OPTEE_FUNCID_RECV		0x00F7U
+#define OPTEE_FUNCID_ETH_XMIT	0x00F8U
+#define OPTEE_FUNCID_ETH_RECV	0x00F9U
+#define OPTEE_FUNCID_PFE_ADD_TX	0x00FAU
+#define OPTEE_FUNCID_PFE_ADD_RX	0x00FBU
+#define OPTEE_FUNCID_CAN_ALLOCATE_BUFFER	0x00FCU
+#define OPTEE_FUNCID_CAN_FREE_BUFFER		0x00FDU
+
+#define OPTEE_SMC_FUNCID_CAN_NOTIFY OPTEE_FUNCID_CAN_NOTIFY
+#define OPTEE_SMC_CALL_CAN_NOTIFY \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_NOTIFY)
+
+#define OPTEE_SMC_FUNCID_READ_BE OPTEE_FUNCID_READ_BE
+#define OPTEE_SMC_CALL_READ_BE\
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_READ_BE)
+
+#define OPTEE_SMC_FUNCID_READ_LE OPTEE_FUNCID_READ_LE
+#define OPTEE_SMC_CALL_READ_LE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_READ_LE)
+
+#define OPTEE_SMC_FUNCID_WRITE_LE OPTEE_FUNCID_WRITE_LE
+#define OPTEE_SMC_CALL_WRITE_LE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_WRITE_LE)
+
+#define OPTEE_SMC_FUNCID_WRITE_BE OPTEE_FUNCID_WRITE_BE
+#define OPTEE_SMC_CALL_WRITE_BE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_WRITE_BE)
+
+#define OPTEE_SMC_FUNCID_XMIT OPTEE_FUNCID_XMIT
+#define OPTEE_SMC_CALL_XMIT \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_XMIT)
+
+#define OPTEE_SMC_FUNCID_RECV OPTEE_FUNCID_RECV
+#define OPTEE_SMC_CALL_RECV \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_RECV)
+
+#define OPTEE_SMC_FUNCID_ETH_XMIT OPTEE_FUNCID_ETH_XMIT
+#define OPTEE_SMC_CALL_ETH_XMIT \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_ETH_XMIT)
+
+#define OPTEE_SMC_FUNCID_ETH_RECV OPTEE_FUNCID_ETH_RECV
+#define OPTEE_SMC_CALL_ETH_RECV \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_ETH_RECV)
+
+#define OPTEE_SMC_FUNCID_PFE_ADD_RX OPTEE_FUNCID_PFE_ADD_RX
+#define OPTEE_SMC_CALL_PFE_ADD_RX \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_PFE_ADD_RX)
+
+#define OPTEE_SMC_FUNCID_PFE_ADD_TX OPTEE_FUNCID_PFE_ADD_TX
+#define OPTEE_SMC_CALL_PFE_ADD_TX \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_PFE_ADD_TX)
+
+#define OPTEE_SMC_FUNCID_CAN_ALLOCATE_BUFFER OPTEE_FUNCID_CAN_ALLOCATE_BUFFER
+#define OPTEE_SMC_CALL_CAN_ALLOCATE_BUFFER \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_ALLOCATE_BUFFER)
+
+#define OPTEE_SMC_FUNCID_CAN_FREE_BUFFER OPTEE_FUNCID_CAN_FREE_BUFFER
+#define OPTEE_SMC_CALL_CAN_FREE_BUFFER \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_CAN_FREE_BUFFER)
+
+
 /*
  * Call with struct optee_msg_arg as argument
  *
diff --git a/core/arch/arm/plat-s32/main.c b/core/arch/arm/plat-s32/main.c
index 432113f15..a56bf584d 100644
--- a/core/arch/arm/plat-s32/main.c
+++ b/core/arch/arm/plat-s32/main.c
@@ -17,17 +17,35 @@ register_phys_mem(MEM_AREA_IO_NSEC, CONSOLE_UART_BASE,
 
 register_phys_mem(MEM_AREA_IO_SEC, GICD_BASE, GIC_DIST_REG_SIZE);
 
+register_phys_mem(MEM_AREA_IO_SEC, FLEXCAN_0_BASE, FLEXCAN_0_SIZE);
+register_phys_mem(MEM_AREA_IO_SEC, FLEXCAN_1_BASE, FLEXCAN_1_SIZE);
+//register_ddr(0xE0000000UL, 0x3000000ul);
+register_phys_mem(MEM_AREA_NSEC_SHM, 0xE0000000UL, 0x3000000ul);
 void boot_primary_init_intc(void)
 {
 	/* Initialize GIC */
 	gic_init(0, GICD_BASE);
 }
 
+static void sorhta_flexcan_init(void)
+{
+	struct io_pa_va can0;
+	struct io_pa_va can1;
+	vaddr_t _;
+	can0.pa = FLEXCAN_0_BASE;
+	can0.va = 0;
+	can1.pa = FLEXCAN_1_BASE;
+	can1.va = 0;
+	_ = io_pa_or_va(&can0, FLEXCAN_0_SIZE);
+	_ = io_pa_or_va(&can1, FLEXCAN_1_SIZE);
+}
+
 void console_init(void)
 {
 	s32_uart_init(&console_data, CONSOLE_UART_BASE, CONSOLE_UART_SIZE,
 		      CONSOLE_UART_CLK_IN_HZ, CONSOLE_UART_BAUDRATE);
 	register_serial_console(&console_data.chip);
+	sorhta_flexcan_init();
 }
 
 unsigned long thread_cpu_resume_handler(unsigned long a0 __unused,
@@ -35,6 +53,6 @@ unsigned long thread_cpu_resume_handler(unsigned long a0 __unused,
 {
 	s32_uart_init(&console_data, CONSOLE_UART_BASE, CONSOLE_UART_SIZE,
 		      CONSOLE_UART_CLK_IN_HZ, CONSOLE_UART_BAUDRATE);
-
+	sorhta_flexcan_init();
 	return 0;
-}
+}
\ No newline at end of file
diff --git a/core/arch/arm/plat-s32/platform_config.h b/core/arch/arm/plat-s32/platform_config.h
index 91bfe1d14..26b519ccb 100644
--- a/core/arch/arm/plat-s32/platform_config.h
+++ b/core/arch/arm/plat-s32/platform_config.h
@@ -16,6 +16,11 @@
 #define GIC_BASE	(0x50800000)
 #define GICD_BASE	(GIC_BASE)
 
+#define FLEXCAN_0_BASE          (0x401b4000)
+#define FLEXCAN_0_SIZE          (0xA000)
+#define FLEXCAN_1_BASE          (0x401be000)
+#define FLEXCAN_1_SIZE          (0xA000)
+
 #define DRAM0_NSEC_BASE (CFG_SHMEM_START)
 #define DRAM0_NSEC_SIZE (CFG_SHMEM_SIZE)
 
diff --git a/core/arch/arm/tee/entry_fast.c b/core/arch/arm/tee/entry_fast.c
index 5d54dbebf..4abee9d13 100644
--- a/core/arch/arm/tee/entry_fast.c
+++ b/core/arch/arm/tee/entry_fast.c
@@ -16,6 +16,9 @@
 #include <sm/optee_smc.h>
 #include <sm/watchdog_smc.h>
 #include <tee/entry_fast.h>
+#include <sorhta.h>
+
+#define FUNCID_OPTEE_CAN_NOTIFY 0x84000051
 
 #ifdef CFG_CORE_RESERVED_SHM
 static void tee_entry_get_shm_config(struct thread_smc_args *args)
@@ -234,9 +237,24 @@ static void tee_entry_watchdog(struct thread_smc_args *args)
  */
 void __tee_entry_fast(struct thread_smc_args *args)
 {
+	//IMSG("Got sorhta can request");
 	switch (args->a0) {
-
 	/* Generic functions */
+	case OPTEE_SMC_CALL_CAN_NOTIFY:
+	case OPTEE_SMC_CALL_READ_BE:
+	case OPTEE_SMC_CALL_WRITE_BE:
+	case OPTEE_SMC_CALL_READ_LE:
+	case OPTEE_SMC_CALL_XMIT:
+	case OPTEE_SMC_CALL_RECV:
+	case OPTEE_SMC_CALL_ETH_XMIT:
+	case OPTEE_SMC_CALL_ETH_RECV:
+	case OPTEE_SMC_CALL_PFE_ADD_RX:
+	case OPTEE_SMC_CALL_PFE_ADD_TX:
+	case OPTEE_SMC_CALL_CAN_ALLOCATE_BUFFER:
+	case OPTEE_SMC_CALL_CAN_FREE_BUFFER:
+	case OPTEE_SMC_CALL_WRITE_LE:
+		handle_sor_hta_request(args);
+		break;
 	case OPTEE_SMC_CALLS_COUNT:
 		tee_entry_get_api_call_count(args);
 		break;
diff --git a/core/core.mk b/core/core.mk
index b023e46ac..649d3d570 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -156,6 +156,10 @@ libname = unw
 libdir = lib/libunw
 include mk/lib.mk
 
+libname = sorhta
+libdir = core/lib/libsorhta
+include mk/lib.mk
+
 ifeq ($(CFG_SCMI_SCPFW),y)
 libname = scmi-server
 libdir = core/lib/scmi-server
diff --git a/core/drivers/gic.c b/core/drivers/gic.c
index 6d5b7777c..f360a3bf0 100644
--- a/core/drivers/gic.c
+++ b/core/drivers/gic.c
@@ -54,7 +54,7 @@
 #define NUM_SGI			16
 
 /* Number of Non-secure Software Generated Interrupt */
-#define NUM_NS_SGI		8
+#define NUM_NS_SGI		9
 
 /* Number of interrupts in one register */
 #define NUM_INTS_PER_REG	32
diff --git a/core/drivers/sor_automotive_hta.c b/core/drivers/sor_automotive_hta.c
new file mode 100644
index 000000000..760170705
--- /dev/null
+++ b/core/drivers/sor_automotive_hta.c
@@ -0,0 +1,94 @@
+#include <kernel/panic.h>
+#include <sm/optee_smc.h>
+#include <trace.h>
+#include <kernel/pseudo_ta.h>
+#include <kernel/spinlock.h>
+#include <io.h>
+
+#define SMC_OPTEE_CAN_NOTIFY    0x84000051
+
+static unsigned int mu_spinlock = SPINLOCK_UNLOCK;
+
+static TEE_Result can_tx_notify(uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
+{
+    DMSG("CAN TX Notification received in OP-TEE driver");
+    return TEE_SUCCESS;
+}
+
+static TEE_Result io_read_le(uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
+{
+    uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_VALUE_OUTPUT, 
+                                                TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+    if(param_types != exp_param_types)
+    {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    cpu_spin_lock(&mu_spinlock);
+    {
+        vaddr_t address = (vaddr_t)params[0].value.a;
+        uint32_t val = io_read32(address);
+        params[1].value.a = val;
+    }
+    cpu_spin_unlock(&mu_spinlock);
+    return TEE_SUCCESS;
+}
+
+static TEE_Result io_read_be(uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
+{
+    uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_VALUE_OUTPUT, 
+                                                TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+    if(param_types != exp_param_types)
+    {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    cpu_spin_lock(&mu_spinlock);
+    {
+        vaddr_t address = (vaddr_t)params[0].value.a;
+        uint32_t val = get_be32((const void*)address);
+        params[1].value.a = val;
+    }
+    cpu_spin_unlock(&mu_spinlock);
+    return TEE_SUCCESS;
+}
+
+static TEE_Result io_write_be(uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
+{
+    uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_VALUE_INPUT,
+                                                TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+    if (param_types != exp_param_types){
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    cpu_spin_lock(&mu_spinlock);
+    {
+        vaddr_t address = (vaddr_t)params[0].value.a;
+        uint32_t val = params[1].value.a;
+        put_be32((void*)address, val);
+    }
+    cpu_spin_unlock(&mu_spinlock);
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result io_write_le(uint32_t param_types, TEE_Param params[TEE_NUM_PARAMS])
+{
+    uint32_t exp_param_types = TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT, TEE_PARAM_TYPE_VALUE_INPUT,
+                                                TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE);
+    if (param_types != exp_param_types){
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    cpu_spin_lock(&mu_spinlock);
+    {
+        vaddr_t address = (vaddr_t)params[0].value.a;
+        uint32_t val = params[1].value.a;
+        io_write32_be(address, val);
+    }
+    cpu_spin_unlock(&mu_spinlock);
+
+    return TEE_SUCCESS;
+}
+
+DECLARE_KEEP_PAGER(can_tx_notify);
\ No newline at end of file
diff --git a/core/drivers/sorhta/ethernet.c b/core/drivers/sorhta/ethernet.c
new file mode 100644
index 000000000..8c1a97e66
--- /dev/null
+++ b/core/drivers/sorhta/ethernet.c
@@ -0,0 +1,21 @@
+#include <sorhta.h>
+#include <ethernet.h>
+
+void sor_eth_notify(struct thread_smc_args *args __unused)
+{
+	//EMSG("SORHTA_ETH: Received ethernet notification\n");
+}
+
+void sor_eth_add_tx_ring(struct thread_smc_args *args)
+{
+	uint32_t chnl_idx = (uint32_t)args->a1;
+	uintptr_t ring_ptr = (uintptr_t)args->a2;
+	//pfe_add_tx_ring(chnl_idx, ring_ptr);
+}
+
+void sor_eth_add_rx_ring(struct thread_smc_args *args)
+{
+	uint32_t chnl_idx = (uint32_t)args->a1;
+	uintptr_t ring_ptr = (uintptr_t)args->a2;
+	//pfe_add_rx_ring(chnl_idx, ring_ptr);
+}
diff --git a/core/drivers/sorhta/flexcan-buffers.c b/core/drivers/sorhta/flexcan-buffers.c
new file mode 100644
index 000000000..5a38d6d50
--- /dev/null
+++ b/core/drivers/sorhta/flexcan-buffers.c
@@ -0,0 +1,538 @@
+
+
+#include <kernel/interrupt.h>
+#include <libfdt.h>
+#include <initcall.h>
+#include <kernel/dt.h>
+#include <mm/core_mmu.h>
+#include <kernel/misc.h>
+#include <tee/cache.h>
+#include <optee_msg.h>
+#include <flexcan-buffers.h>
+#include <stddef.h>
+#include <kernel/cache_helpers.h>
+/**
+ * Secure Buffer allocation, simple management of PID-to-Buffers.
+ */
+/*================================================================================================*/
+#define CANFD_MAX_DLEN  64
+typedef struct canfd_frame {
+	uint32_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	uint8_t    len;     /* frame payload length in byte */
+	uint8_t    flags;   /* additional flags for CAN FD */
+	uint8_t    __res0;  /* reserved / padding */
+	uint8_t    __res1;  /* reserved / padding */
+	uint8_t    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
+} canfd_frame_t;
+
+/* Global hash map instance */
+static pid_buffer_hashmap_t pid_map;
+
+/*
+ * Simple hash function for PIDs
+ */
+static inline unsigned int hash_pid(uint32_t pid)
+{
+    /* Simple multiplicative hash with prime number */
+    return (pid * HASH_MULTIPLIER) % PID_MAP_SIZE;
+}
+
+/*
+ * Find first free entry index in the pre-allocated entry pool
+ */
+static int find_free_entry(void)
+{
+    int i, j, bit;
+
+    for (i = 0; i < (PID_MAP_MAX_ENTRIES / 32); i++) {
+        if (pid_map.free_entries_bitmap[i] == 0xFFFFFFFFU) {
+            /* All bits set, no free entries in this word */
+            continue;
+        }
+
+        /* Find first clear bit in word */
+        for (j = 0; j < 32; j++) {
+            bit = 1U << j;
+            if ((pid_map.free_entries_bitmap[i] & bit) == 0) {
+                /* Found free entry */
+                pid_map.free_entries_bitmap[i] |= bit;
+                return (i * 32) + j;
+            }
+        }
+    }
+
+    /* No free entries found */
+    return -1;
+}
+
+/*
+ * Mark an entry as free in the bitmap
+ */
+static void free_entry(int index)
+{
+    int word_index = index / 32;
+    int bit_index = index % 32;
+
+    assert(index >= 0 && index < PID_MAP_MAX_ENTRIES);
+    pid_map.free_entries_bitmap[word_index] &= ~(1U << bit_index);
+}
+
+/*
+ * Initialize the PID to buffer hash map
+ */
+static void pid_buffer_map_init(void)
+{
+    /* Zero out the entire structure */
+    memset(&pid_map, 0, sizeof(pid_map));
+    
+    /* All entries are initially free (bitmap all zeros) */
+    EMSG("PID buffer map initialized with %u buckets\n", PID_MAP_SIZE);
+}
+
+/*
+ * Add a PID-to-buffer mapping
+ * Returns 0 on success, negative error code on failure
+ */
+static int pid_buffer_map_add(uint32_t pid, uintptr_t buffer_addr)
+{
+    pid_buffer_entry_t *entry;
+    unsigned int bucket;
+    int index;
+    int result = 0;
+
+    assert(buffer_addr != 0);
+
+    /* Get hash bucket for this PID */
+    bucket = hash_pid(pid);
+
+    cpu_spin_lock(&pid_map.lock);
+
+    /* Check if this PID already exists */
+    entry = pid_map.buckets[bucket];
+    while (entry != NULL) {
+        if (entry->pid == pid) {
+            /* Update existing entry */
+            entry->buffer_addr = buffer_addr;
+            cpu_spin_unlock(&pid_map.lock);
+            return 0;
+        }
+        entry = entry->next;
+    }
+
+    /* Find a free entry slot */
+    if (pid_map.count >= PID_MAP_MAX_ENTRIES) {
+        EMSG("PID buffer map is full\n");
+        result = -1;
+        goto out;
+    }
+
+    index = find_free_entry();
+    if (index < 0) {
+        EMSG("Failed to find free entry despite count check\n");
+        result = -1;
+        goto out;
+    }
+
+    /* Initialize the new entry */
+    entry = &pid_map.entries[index];
+    entry->pid = pid;
+    entry->buffer_addr = buffer_addr;
+
+    /* Add to head of bucket chain */
+    entry->next = pid_map.buckets[bucket];
+    pid_map.buckets[bucket] = entry;
+
+    /* Update stats */
+    pid_map.count++;
+
+    EMSG("Added PID %u -> buffer 0x%lx mapping (bucket %u)\n", 
+            pid, buffer_addr, bucket);
+
+out:
+    cpu_spin_unlock(&pid_map.lock);
+    return result;
+}
+
+/*
+ * Look up a buffer address by PID
+ * Returns buffer address or 0 if not found
+ */
+static uintptr_t pid_buffer_map_lookup(uint32_t pid)
+{
+    pid_buffer_entry_t *entry;
+    unsigned int bucket;
+    uintptr_t addr = 0;
+
+    /* Get hash bucket for this PID */
+    bucket = hash_pid(pid);
+
+    cpu_spin_lock(&pid_map.lock);
+
+    /* Search the bucket chain */
+    entry = pid_map.buckets[bucket];
+    while (entry != NULL) {
+        if (entry->pid == pid) {
+            addr = entry->buffer_addr;
+            break;
+        }
+        entry = entry->next;
+    }
+
+    cpu_spin_unlock(&pid_map.lock);
+    return addr;
+}
+
+/*
+ * Remove a mapping by PID
+ * Returns 0 on success, -1 if not found
+ */
+static int pid_buffer_map_remove(uint32_t pid)
+{
+    pid_buffer_entry_t *entry, *prev;
+    unsigned int bucket;
+    int index, result = -1;
+
+    /* Get hash bucket for this PID */
+    bucket = hash_pid(pid);
+
+    cpu_spin_lock(&pid_map.lock);
+
+    /* Search the bucket chain */
+    prev = NULL;
+    entry = pid_map.buckets[bucket];
+    
+    while (entry != NULL) {
+        if (entry->pid == pid) {
+            /* Found it - remove from chain */
+            if (prev == NULL) {
+                pid_map.buckets[bucket] = entry->next;
+            } else {
+                prev->next = entry->next;
+            }
+            
+            /* Calculate index and mark as free */
+            index = entry - pid_map.entries;
+            free_entry(index);
+            
+            /* Clear entry data */
+            entry->pid = 0;
+            entry->buffer_addr = 0;
+            entry->next = NULL;
+            
+            /* Update stats */
+            assert(pid_map.count > 0);
+            pid_map.count--;
+            
+            EMSG("Removed PID %u mapping (bucket %u)\n", pid, bucket);
+            result = 0;
+            break;
+        }
+        
+        prev = entry;
+        entry = entry->next;
+    }
+
+    cpu_spin_unlock(&pid_map.lock);
+    return result;
+}
+
+/*
+ * Get number of entries in the map
+ */
+static size_t pid_buffer_map_count(void)
+{
+    size_t count;
+    
+    cpu_spin_lock(&pid_map.lock);
+    count = pid_map.count;
+    cpu_spin_unlock(&pid_map.lock);
+    
+    return count;
+}
+
+/*
+ * Dump the hash map contents for debugging
+ */
+static void pid_buffer_map_dump(void)
+{
+    pid_buffer_entry_t *entry;
+    size_t chains = 0;
+    size_t max_chain = 0;
+    size_t chain_len;
+    unsigned int i;
+
+    cpu_spin_lock(&pid_map.lock);
+
+    EMSG("PID buffer map stats: %zu entries in %u buckets\n", 
+         pid_map.count, PID_MAP_SIZE);
+
+    for (i = 0; i < PID_MAP_SIZE; i++) {
+        entry = pid_map.buckets[i];
+        if (entry == NULL) {
+            continue;
+        }
+
+        chains++;
+        chain_len = 0;
+
+        EMSG("Bucket %3u: ", i);
+        while (entry != NULL) {
+            EMSG("PID %u->0x%lx  ", entry->pid, entry->buffer_addr);
+            entry = entry->next;
+            chain_len++;
+        }
+        EMSG("\n");
+
+        if (chain_len > max_chain) {
+            max_chain = chain_len;
+        }
+    }
+
+    EMSG("Used buckets: %zu, Max chain length: %zu\n", chains, max_chain);
+    cpu_spin_unlock(&pid_map.lock);
+}
+
+/**
+ * Can Buffer Functions
+ */
+static uintptr_t can_buffer_pool_base;
+static uintptr_t can_buffer_pool_size;
+static uint32_t can_buffer_pool_lock;
+static unsigned int buffer_bitmap[MAX_CAN_BUFFERS / 32];
+
+/*
+ * Initialize the CAN secure buffer subsystem
+ *
+ * Parameters:
+ *   pool_base - Physical base address of buffer pool
+ *   pool_size - Size of buffer pool in bytes
+ *
+ * Returns:
+ *   0 on success, negative error code on failure
+ */
+int can_secure_buffer_init(uintptr_t pool_base, size_t pool_size)
+{
+    /* Validate parameters */
+    if ((pool_base == 0) || (pool_size < CAN_BUFFER_SIZE)) {
+        EMSG("Invalid CAN buffer pool parameters\n");
+        return -1;
+    }
+    
+    /* Ensure base address is page-aligned */
+    if ((pool_base & (CAN_BUFFER_SIZE - 1)) != 0) {
+        EMSG("CAN buffer pool base must be %u-byte aligned\n", CAN_BUFFER_SIZE);
+        return -1;
+    }
+    
+    EMSG("Initializing CAN secure buffer pool at 0x%lx, size %zu bytes\n",
+         pool_base, pool_size);
+    
+    /* Initialize buffer pool tracking */
+    can_buffer_pool_base = pool_base;
+    can_buffer_pool_size = pool_size;
+    
+    /* Clear buffer allocation bitmap (all buffers free) */
+    memset(buffer_bitmap, 0, sizeof(buffer_bitmap));
+    
+    /* Initialize PID to buffer map */
+    pid_buffer_map_init();
+    
+    return 0;
+}
+
+
+/*
+ * Find first free buffer in the buffer pool
+ * Must be called with can_buffer_pool_lock held
+ *
+ * Returns:
+ *   Buffer index if available, -1 if no buffers available
+ */
+static int find_free_buffer(void)
+{
+    int i, j, bit;
+    
+    for (i = 0; i < (MAX_CAN_BUFFERS / 32); i++) {
+        if (buffer_bitmap[i] == 0xFFFFFFFFU) {
+            /* All bits set, no free buffers in this word */
+            continue;
+        }
+        
+        /* Find first clear bit in word */
+        for (j = 0; j < 32; j++) {
+            bit = 1U << j;
+            if ((buffer_bitmap[i] & bit) == 0) {
+                /* Found free buffer */
+                buffer_bitmap[i] |= bit;
+                return (i * 32) + j;
+            }
+        }
+    }
+    
+    /* No free buffers found */
+    return -1;
+}
+
+/*
+ * Convert buffer index to physical address
+ */
+static inline uintptr_t buffer_index_to_addr(int index)
+{
+    assert(index >= 0 && index < MAX_CAN_BUFFERS);
+    return can_buffer_pool_base + (index * CAN_BUFFER_SIZE);
+}
+
+/*
+ * Convert physical address to buffer index
+ */
+static inline int addr_to_buffer_index(uintptr_t addr)
+{
+    assert(addr >= can_buffer_pool_base);
+    assert(addr < (can_buffer_pool_base + can_buffer_pool_size));
+    assert((addr - can_buffer_pool_base) % CAN_BUFFER_SIZE == 0);
+    
+    return (addr - can_buffer_pool_base) / CAN_BUFFER_SIZE;
+}
+
+/*
+ * Mark a buffer as free in the bitmap
+ */
+static void free_buffer(int index)
+{
+    int word_index = index / 32;
+    int bit_index = index % 32;
+    
+    assert(index >= 0 && index < MAX_CAN_BUFFERS);
+    
+    cpu_spin_lock(&can_buffer_pool_lock);
+    buffer_bitmap[word_index] &= ~(1U << bit_index);
+    cpu_spin_unlock(&can_buffer_pool_lock);
+}
+
+/*
+ * Allocate a secure CAN buffer for a process
+ *
+ * Parameters:
+ *   pid - Process ID requesting buffer
+ *
+ * Returns:
+ *   Physical address of allocated buffer or 0 on failure
+ */
+uintptr_t can_secure_buffer_allocate(uint32_t pid)
+{
+    int buffer_index;
+    uintptr_t phys_addr;
+    uintptr_t virt_addr;
+    
+    /* Check if PID already has a buffer */
+    phys_addr = pid_buffer_map_lookup(pid);
+    if (phys_addr != 0) {
+        EMSG("PID %u already has buffer at 0x%lx\n", pid, phys_addr);
+        return phys_addr;
+    }
+    
+    /* Allocate a buffer */
+    cpu_spin_lock(&can_buffer_pool_lock);
+    buffer_index = find_free_buffer();
+    cpu_spin_unlock(&can_buffer_pool_lock);
+    
+    if (buffer_index < 0) {
+        EMSG("No free CAN buffers available\n");
+        return 0;
+    }
+    
+    /* Convert to physical address */
+    phys_addr = buffer_index_to_addr(buffer_index);
+    
+    /* Zero buffer contents */
+    virt_addr = phys_to_virt(phys_addr, MEM_AREA_NSEC_SHM, 1);
+    memset((void *)virt_addr, 0, CAN_BUFFER_SIZE);
+    
+    /* Add to PID map */
+    if (pid_buffer_map_add(pid, phys_addr) != 0) {
+        /* Failed to add to map, free the buffer */
+        free_buffer(buffer_index);
+        EMSG("Failed to map PID %u to buffer\n", pid);
+        return 0;
+    }
+    
+    EMSG("Allocated CAN buffer 0x%lx for PID %u\n", phys_addr, pid);
+    return phys_addr;
+}
+
+/*
+ * Free a secure CAN buffer
+ *
+ * Parameters:
+ *   pid - Process ID whose buffer should be freed
+ *
+ * Returns:
+ *   0 on success, -1 if not found
+ */
+int can_secure_buffer_free(uint32_t pid)
+{
+    uintptr_t phys_addr;
+    int buffer_index;
+    
+    /* Look up the buffer */
+    phys_addr = pid_buffer_map_lookup(pid);
+    if (phys_addr == 0) {
+        EMSG("No buffer found for PID %u\n", pid);
+        return -1;
+    }
+    
+    /* Convert to buffer index */
+    buffer_index = addr_to_buffer_index(phys_addr);
+    
+    /* Remove from PID map */
+    if (pid_buffer_map_remove(pid) != 0) {
+        EMSG("Failed to remove PID %u from buffer map\n", pid);
+        return -1;
+    }
+    
+    /* Zero buffer contents for security */
+    memset((void *)phys_addr, 0, CAN_BUFFER_SIZE);
+    
+    /* Free the buffer */
+    free_buffer(buffer_index);
+    
+    EMSG("Freed CAN buffer 0x%lx for PID %u\n", phys_addr, pid);
+    return 0;
+}
+
+/*
+ * Get info about allocated CAN buffers
+ */
+void can_secure_buffer_EMSG(void)
+{
+    size_t allocated = pid_buffer_map_count();
+    size_t total = MAX_CAN_BUFFERS;
+    
+    EMSG("CAN buffer pool stats: %zu/%zu buffers allocated\n", allocated, total);
+    EMSG("Buffer size: %u bytes, Total pool size: %zu bytes\n", 
+         CAN_BUFFER_SIZE, can_buffer_pool_size);
+    
+    pid_buffer_map_dump();
+}
+
+/**
+ * Free message buffer
+ */
+int can_free_message_buffer(void* message_addr) {
+    
+    struct secv_can_buffer_rec* rec = (struct secv_can_buffer_rec*)((size_t)message_addr & ~((size_t)0xFFF));
+    uint64_t message_offset = ((char*)message_addr - (char*)rec - ((sizeof(struct secv_can_buffer_rec) + 0x7) & ~((size_t)0x7)));
+
+    message_offset /= sizeof(struct canfd_frame);
+    dcache_inv_range((void*)rec, sizeof(struct secv_can_buffer_rec));
+    uint64_t bit = ((size_t)1 << message_offset);
+    if(rec->available & bit) {
+        rec->available &= ~bit;
+        return 0;
+    } else {
+        return -1;
+    }
+    dcache_clean_range((void*)rec, sizeof(struct secv_can_buffer_rec));
+}
+
+/*===============================================================================================*/
\ No newline at end of file
diff --git a/core/drivers/sorhta/flexcan.c b/core/drivers/sorhta/flexcan.c
new file mode 100644
index 000000000..bd55a75c6
--- /dev/null
+++ b/core/drivers/sorhta/flexcan.c
@@ -0,0 +1,512 @@
+#include <sorhta.h>
+#include <flexcan.h>
+#include <kernel/interrupt.h>
+#include <libfdt.h>
+#include <initcall.h>
+#include <kernel/dt.h>
+#include <mm/core_mmu.h>
+#include <kernel/misc.h>
+#include <tee/cache.h>
+#include <optee_msg.h>
+#include <flexcan-buffers.h>
+#include <stddef.h>
+#include <kernel/cache_helpers.h>
+
+struct flexcan_priv* flexcan_privs[NUM_FLEXCAN_INTERFACES] = {NULL};
+const char* flexcan_compatible = "nxp,s32cc-flexcan";
+static struct itr_handler flexcan_handlers [NUM_FLEXCAN_INTERFACES*2];
+static void* secv_shmem_virt_addr = NULL;
+uint32_t lock;
+
+static struct secv_tx_ring_buffers local_tx_rings[NUM_FLEXCAN_INTERFACES];
+static struct secv_rx_ring_buffers local_rx_rings[NUM_FLEXCAN_INTERFACES];
+static size_t tx_index = 0;
+
+static struct secv_tx_ring_buffers* secv_flexcan_tx_rings[NUM_FLEXCAN_INTERFACES] = {NULL};
+static struct secv_rx_ring_buffers* secv_flexcan_rx_rings[NUM_FLEXCAN_INTERFACES] = {NULL};
+
+/**
+ * flexcan_ioread32 - read from a 32-bit MU register
+ * @addr: address of the register to read from
+ *
+ * Return: value of read register
+ */
+static uint32_t flexcan_io_read32(const uint32_t *addr)
+{
+	return io_read32((vaddr_t)addr);
+}
+
+/**
+ * hse_iowrite32 - write value to a 32-bit MU register
+ * @addr: address of the register to write to
+ * @val: value to write
+ *
+ */
+static void flexcan_io_write32(const uint32_t *addr, uint32_t val)
+{
+	io_write32((vaddr_t)addr, val);
+}
+
+void sor_can_send_frame(struct thread_smc_args *args) {
+    uint32_t interface_index = (uint32_t)args->a1;
+    //EMSG("Interface index: %d\n", interface_index);
+    cpu_spin_lock(&lock);
+    handle_flexcan_tx_smc(interface_index);
+    cpu_spin_unlock(&lock);
+}
+
+void sor_can_recv_frame(struct thread_smc_args *args)
+{
+    uint32_t interface_index = (uint32_t)args->a1;
+    handle_flexcan_rx_smc(interface_index);
+}
+
+void sor_can_alloc_buffer(struct thread_smc_args *args)
+{
+    uint32_t pid = (uint32_t)args->a1;
+    uintptr_t res;
+    handle_flexcan_secure_can_buffer_allocate(pid, &res);
+    //EMSG("Finished handling can buffer alloc: %lx\n", (unsigned long)res);
+    args->a1 = (uint64_t)res;
+}
+
+void sor_can_free_buffer(struct thread_smc_args *args)
+{
+    uint32_t pid = (uint32_t)args->a1;
+    handle_flexcan_secure_can_buffer_free(pid);
+}
+
+
+/* Memory barrier helpers for OP-TEE */
+static inline void optee_wmb(void)
+{
+    asm volatile ("dmb st" : : : "memory");
+}
+
+static inline void optee_rmb(void)
+{
+    asm volatile ("dmb ld" : : : "memory");
+}
+
+
+static inline void optee_dsb(void)
+{
+    asm volatile ("dsb sy" : : : "memory");
+}
+
+static inline void send_sgi(void) {
+    itr_raise_sgi(SECV_FLEXCAN_SGI_NUM, 1 << get_core_pos());
+}
+
+static inline void notify_nw_driver_recv(struct flexcan_priv* priv) {
+    uint32_t bit_index = SECV_RECV_BIT_IDX;
+    uint64_t bitmap;
+    optee_rmb();
+    bitmap = priv->interrupts_bitmap;
+    bitmap |= (1 << bit_index);
+    priv->interrupts_bitmap = bitmap;
+    optee_wmb();
+    optee_dsb();
+    dcache_clean_range(&priv->interrupts_bitmap, sizeof(uint64_t));
+    optee_dsb();
+    send_sgi();
+}
+
+static inline void notify_nw_driver_send(struct flexcan_priv* priv) {
+    uint32_t bit_index = SECV_SEND_COMPLETE_BIT_IDX;
+    uint64_t bitmap;
+    optee_rmb();
+    bitmap = priv->interrupts_bitmap;
+    bitmap |= (1 << bit_index);
+    priv->interrupts_bitmap = bitmap;
+    optee_wmb();
+    optee_dsb();
+    dcache_clean_range(&priv->interrupts_bitmap, sizeof(uint64_t));
+    optee_dsb();
+    send_sgi();
+}
+
+
+static void flexcan_enable_interrupts(uint32_t interface_idx)
+{
+    if(interface_idx == 0){
+        itr_enable(flexcan_handlers[0].it);
+        itr_enable(flexcan_handlers[1].it);
+    } else if(interface_idx == 1){
+        itr_enable(flexcan_handlers[2].it);
+        itr_enable(flexcan_handlers[3].it);
+    }else {
+        DMSG("Invalid interface index %d",interface_idx);
+        panic();
+    }
+}
+
+static void flexcan_disable_interrupts(uint32_t interface_idx)
+{
+    if(interface_idx == 0){
+        itr_disable(flexcan_handlers[0].it);
+        itr_disable(flexcan_handlers[1].it);
+    } else if(interface_idx == 1){
+        itr_disable(flexcan_handlers[2].it);
+        itr_disable(flexcan_handlers[3].it);
+    }else {
+        EMSG("Invalid interface index %d",interface_idx);
+        panic();
+    }
+}
+
+static inline int ensure_flexcan_priv_initialized(struct flexcan_priv* priv, uint32_t interface_index) {
+    if(priv == NULL || priv->nsec_initialized != 1) {
+        return -1;
+    }
+    if(priv->sec_initialized != 1) {
+        priv->interface_idx = interface_index;
+        priv->tx_mb = phys_to_virt(priv->tx_mb, MEM_AREA_IO_SEC, 1);
+        priv->tx_mb_reserved = phys_to_virt(priv->tx_mb_reserved, MEM_AREA_IO_SEC, 1);
+        priv->regs = phys_to_virt(priv->regs, MEM_AREA_IO_SEC, 1);
+        priv->sec_initialized = 1;
+    }
+    return 0;
+}
+
+static void handle_tx(struct flexcan_priv* priv, struct tx_mb* tx_mb, uint8_t* rules, size_t num_rules)
+{
+    uint32_t len, data, i; 
+    struct canfd_frame* frame; 
+    uintptr_t frame_page;
+    
+    
+    frame = tx_mb->data;
+    //EMSG("Actually handling Tx, frame: %lx %lx\n", (unsigned long)frame, (unsigned long)priv->interrupts_bitmap);
+    // the NW driver passes the physical address.
+    frame = phys_to_virt((paddr_t)frame, MEM_AREA_NSEC_SHM, 1);
+
+    // translate this at once, we will need to free it from SSMe anyway
+    tx_mb->data = frame;
+
+    //EMSG("Translated frame: %lx\n", (unsigned long)frame);
+    len = frame->len;
+    i = 0;
+
+    while (i < len) 
+    {
+        data = be32_to_cpup((const uint32_t*)&frame->data[i]);
+        flexcan_io_write32(&priv->tx_mb->data[i / sizeof(uint32_t)], data);
+        i += sizeof(uint32_t);
+    }
+
+    flexcan_io_write32(&priv->tx_mb->can_id, tx_mb->can_id);
+    flexcan_io_write32(&priv->tx_mb->can_ctrl, tx_mb->can_ctrl);
+    flexcan_io_write32(&priv->tx_mb_reserved->can_ctrl, FLEXCAN_MB_CODE_TX_INACTIVE);
+    flexcan_io_write32(&priv->tx_mb_reserved->can_ctrl, FLEXCAN_MB_CODE_TX_INACTIVE);
+    optee_dsb();
+    //EMSG("Actually handled Tx successfully\n");
+}
+
+static int flexcan_handle_tx_next(struct flexcan_priv* priv, struct secv_tx_ring_buffers* local_tx_ring) 
+{
+    if(tx_index == local_tx_ring->count) {
+        return 0;
+    }
+    //EMSG("Handling the next mb");
+    struct tx_mb *tx_mb = &local_tx_ring->mbs[tx_index];
+    uint8_t rules[1] = {0};
+    handle_tx(priv, tx_mb, rules, 1);
+    return 1;
+}
+
+static inline void get_set_bits(uint64_t value, uint8_t bits[64], size_t *count) {
+    *count = 0;
+    
+    while (value != 0) {
+        bits[*count] = __builtin_ctzll(value);  // count trailing zeros
+        (*count)++;
+        value &= value - 1;  // clear lowest set bit
+    }
+}
+
+/**
+ * This function reads the actual message from the CAN controller.
+ * We've overly simplified it, retaining only needed code after checking the
+ * NW driver.
+ */
+static void read_mailbox(struct flexcan_priv* priv, uint64_t mb_index, struct secv_rx_ring_buffers* local_rx_ring)
+{
+    struct flexcan_mb* mb = flexcan_get_mb(priv, mb_index);
+    uint32_t reg_ctrl, reg_id, len, i, data, *data_ptr;
+    struct rx_mb* rx_mb = NULL;
+    
+    do {
+        reg_ctrl = flexcan_io_read32(&mb->can_ctrl);
+    } while(reg_ctrl & FLEXCAN_MB_CODE_RX_BUSY_BIT);
+
+    //EMSG("Reading mailbox %d\n", mb_index);
+    // allocate an RX MB from local queue.
+    if(local_rx_ring->count != NUM_RX_BUFFERS) {
+        rx_mb = &local_rx_ring->mbs[local_rx_ring->count++];
+    
+        reg_id = flexcan_io_read32(&mb->can_id);
+        optee_dsb();
+
+        rx_mb->can_id = reg_id;
+        rx_mb->can_ctrl = reg_ctrl;
+        
+        if((reg_ctrl & FLEXCAN_MB_CNT_EDL) != 0){
+            len = can_fd_dlc2len((reg_ctrl >> 16) & 0xF);
+        } else {
+            len = can_cc_dlc2len((reg_ctrl >> 16) & 0xF);
+        }
+
+        i = 0;
+        while (i < len) {
+            data = flexcan_io_read32(&mb->data[i/sizeof(uint32_t)]);
+            data_ptr = (uint32_t*)(rx_mb->data.data + i);
+            *data_ptr = data;
+            i += sizeof(uint32_t);
+        }
+    }
+    //EMSG("Read mailbox successfully ID: %x CTRL: %x\n", reg_id, reg_ctrl);
+    flexcan_write64(priv, 1 << mb_index, &priv->regs->iflag1);
+    flexcan_io_read32(&priv->regs->timer);
+    optee_dsb();
+}
+
+/**
+ * This is the entry function into handling a receive signal raised by the
+ * CAN controller. The signal may be of an actual received message or 
+ * an end of transmission. we need to handle both here.
+ * Received messages are saved in the local queue, and later moved to the
+ * shared queue to signal the NW driver.
+ * We return a non-zero value if this handling resulted in a transmission completion
+ * detection.
+ */
+static int handle_rx(struct flexcan_priv* priv, struct secv_tx_ring_buffers* local_tx_ring, struct secv_rx_ring_buffers* local_rx_ring)
+{
+    uint64_t reg_iflag_rx;
+    uint8_t set_bits[64] = {0};
+    size_t count = 0;
+    size_t i, mb_index;
+    uint64_t reg_iflag_tx;
+    uint32_t tx_reg_ctrl;
+    int ret = 0;
+
+   
+    while((reg_iflag_rx = flexcan_read_reg_iflag_rx(priv))) {
+        get_set_bits(reg_iflag_rx, set_bits, &count);
+        for(i=0; i<count; i++) {
+            mb_index = set_bits[i];
+            read_mailbox(priv, mb_index, local_rx_ring);
+        }
+    }
+
+    reg_iflag_tx = flexcan_read_reg_iflag_tx(priv);
+    if((reg_iflag_tx & priv->tx_mask) != 0){
+        tx_reg_ctrl = flexcan_io_read32(&priv->tx_mb->can_ctrl);
+        local_tx_ring->mbs[tx_index].can_ctrl_tx = tx_reg_ctrl;
+        
+        // if(can_free_message_buffer(local_tx_ring->mbs[tx_index].data)){
+        //     EMSG("SECV: freeing an unallocated frame? %lx\n", (unsigned long)local_tx_ring->mbs[tx_index].data);
+        // }
+
+        flexcan_io_write32(&priv->tx_mb->can_ctrl, FLEXCAN_MB_CODE_TX_INACTIVE);
+        flexcan_write64(priv, priv->tx_mask, (volatile void*)&priv->regs->iflag1);
+        ret = 1;
+    }
+
+    return ret;
+}
+
+/**
+ * This is the entry function for handling CAN Rx
+ */
+static void flexcan_handle_rx(uint32_t interface_index) {
+    // Disable interrupts
+    flexcan_disable_interrupts(interface_index);
+
+    cpu_spin_lock(&lock);
+    struct flexcan_priv* priv = flexcan_privs[interface_index];
+    if(ensure_flexcan_priv_initialized(priv, interface_index)) {
+        panic("Attempting Flexcan TX on uninitialized interface?");
+    }
+    //EMSG("Handling Rx on interface %d\n", interface_index);
+    int tx_complete = handle_rx(priv, &local_tx_rings[interface_index], &local_rx_rings[interface_index]);
+    //EMSG("Handled Rx successfully %d %d\n", tx_complete, local_rx_rings[interface_index].count);
+    uint32_t i;
+    uint32_t count;
+    if(tx_complete) {
+        tx_index += 1;
+        struct secv_tx_ring_buffers* local_tx_ring = &local_tx_rings[interface_index];
+        // we have transmitted all the existing tx requests.
+        if(!flexcan_handle_tx_next(priv, local_tx_ring)) {
+            for(i = 0; i<local_tx_ring->count; i++) {
+                secv_flexcan_tx_rings[interface_index]->mbs[i].can_ctrl_tx = local_tx_ring->mbs[i].can_ctrl_tx;
+            }
+            notify_nw_driver_send(priv);
+        }
+    }
+    if(local_rx_rings[interface_index].count != 0) {
+        memcpy((void*)&secv_flexcan_rx_rings[interface_index]->mbs[0], (void*)&local_rx_rings[interface_index].mbs[0], local_rx_rings[interface_index].count*sizeof(struct rx_mb));
+
+        count = local_rx_rings[interface_index].count;
+        secv_flexcan_rx_rings[interface_index]->count = count;
+ 
+
+        for(int i=local_rx_rings[interface_index].count; i>0; i--) {
+            secv_flexcan_rx_rings[interface_index]->mbs[i-1] = local_rx_rings[interface_index].mbs[i-1];
+        }
+        memset(&local_rx_rings[interface_index], 0, sizeof(struct secv_rx_ring_buffers));
+        optee_dsb();
+        dcache_clean_range(secv_flexcan_rx_rings[interface_index], sizeof(struct secv_rx_ring_buffers));
+        notify_nw_driver_recv(priv);
+    }
+    cpu_spin_unlock(&lock);
+
+    //reanble interrupts
+    flexcan_enable_interrupts(interface_index);
+}
+
+/**
+ * This is the entry function for handling CAN TX.
+ * this is called when the NW driver issues an SMC call requesting transmission
+ * of a batch of messages.
+ */
+static void flexcan_handle_tx(uint32_t interface_index)
+{
+    struct flexcan_priv* priv = flexcan_privs[interface_index];
+    if(ensure_flexcan_priv_initialized(priv, interface_index)) {
+        panic("Attempting Flexcan TX on uninitialized interface?");
+    }
+
+    dcache_inv_range(secv_flexcan_tx_rings[interface_index], sizeof(struct secv_tx_ring_buffers));
+    optee_dsb();
+    
+
+    local_tx_rings[interface_index].count = secv_flexcan_tx_rings[interface_index]->count;
+    
+    //EMSG("Handling Transmission on interface: %d %d\n", interface_index, local_tx_rings[interface_index].count);
+    
+    // memcpy((void*)&local_tx_rings[interface_index], (void*)secv_flexcan_tx_rings[interface_index], sizeof(struct secv_tx_ring_buffers));
+    // optee_wmb();
+    // optee_dsb();
+    tx_index = 0;
+    for(int i=local_tx_rings[interface_index].count; i>0; i--) {
+        local_tx_rings[interface_index].mbs[i-1] = secv_flexcan_tx_rings[interface_index]->mbs[i-1];
+    }
+// for(int i=0; i<local_tx_rings[interface_index].count; i++){
+//         //EMSG("CAN ID: %u CAN ctrl: %u %u DATA: %lx %lx\n",
+//         local_tx_rings[interface_index].mbs[i].can_id,
+//         local_tx_rings[interface_index].mbs[i].can_ctrl, secv_flexcan_tx_rings[interface_index]->mbs[i].can_ctrl,
+//         (unsigned long)local_tx_rings[interface_index].mbs[i].data, (unsigned long)secv_flexcan_tx_rings[interface_index]->mbs[i].data);
+//     }
+    flexcan_handle_tx_next(priv, &local_tx_rings[interface_index]);
+}
+
+
+TEE_Result handle_flexcan_tx_smc(uint32_t interface_index) {
+    flexcan_handle_tx(interface_index);
+    dsb();
+    return TEE_SUCCESS;
+}
+
+TEE_Result handle_flexcan_rx_smc(uint32_t interface_index)
+{
+    flexcan_handle_rx(interface_index);
+    //EMSG("Finished handling RX: tail %d head %d", rx_ring_buffers[interface_index]->global_metadata.tail, rx_ring_buffers[interface_index]->global_metadata.head);
+    dsb();
+    return TEE_SUCCESS;
+}
+
+TEE_Result handle_flexcan_secure_can_buffer_allocate(uint32_t pid, uintptr_t* addr)
+{
+    //EMSG("Handling flexcan secure buffer alloc");
+    uintptr_t phys_addr = can_secure_buffer_allocate(pid);
+    //EMSG("returning physical address: %lx", (unsigned long)phys_addr);
+    *addr = (uintptr_t)phys_addr;
+    return TEE_SUCCESS;
+}
+
+TEE_Result handle_flexcan_secure_can_buffer_free(uint32_t pid)
+{
+    can_secure_buffer_free(pid);
+    return TEE_SUCCESS;
+}
+
+
+
+static enum itr_return flexcan_rx_handler(struct itr_handler *h __unused)
+{
+    switch(h->it) {
+        case 39+32:
+        case 40+32:
+            flexcan_handle_rx(0);
+            break;
+        case 43+32:
+        case 44+32:
+            flexcan_handle_rx(1);
+            break;
+        default:
+            EMSG("Unknown interrupt caught by SSMe\n");
+    }
+	return ITRR_HANDLED;
+}
+
+static TEE_Result flexcan_driver_init()
+{
+    TEE_Result ret;
+    uint16_t status;
+    int flexcan1_rx_irq_nums[] = {39+32,40+32, 43+32, 44+32};
+    secv_shmem_virt_addr = phys_to_virt(SORHTA_SHMEM_BASE, MEM_AREA_NSEC_SHM, 1);
+    
+#ifdef CFG_CORE_DYN_SHM
+    EMSG("Dynamic memory sharing is enabled");
+#endif
+    if(secv_shmem_virt_addr) {
+        EMSG("Managed to map SORHTA shmem");
+    } else {
+        EMSG("Failed to map SORHTA shmem");
+    }
+
+    can_secure_buffer_init(BUFFER_POOL_BASE, BUFFER_POOL_SIZE);
+    
+    flexcan_privs[0] = (struct flexcan_priv*)((char*)secv_shmem_virt_addr + SORHTA_PRIV0_BASE_OFF);
+    flexcan_privs[1] = (struct flexcan_priv*)((char*)secv_shmem_virt_addr + SORHTA_PRIV1_BASE_OFF);
+
+    secv_flexcan_rx_rings[0] = (struct secv_rx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_RX_SHMEM_BASE0_OFF);
+	secv_flexcan_rx_rings[1] = (struct secv_rx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_RX_SHMEM_BASE1_OFF);
+
+	secv_flexcan_tx_rings[0] = (struct secv_tx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_TX_SHMEM_BASE0_OFF);
+	secv_flexcan_tx_rings[1] = (struct secv_tx_ring_buffers *)((char*)secv_shmem_virt_addr + SORHTA_FLEXCAN_TX_SHMEM_BASE1_OFF);
+
+    flexcan_handlers[0].it = flexcan1_rx_irq_nums[0];
+    flexcan_handlers[0].data = (void*)flexcan_privs[0];
+    flexcan_handlers[0].handler = flexcan_rx_handler;
+    flexcan_handlers[0].flags |= (ITRF_SHARED);
+    flexcan_handlers[1].it = flexcan1_rx_irq_nums[1];
+    flexcan_handlers[1].data = (void*)flexcan_privs[0];;
+    flexcan_handlers[1].handler = flexcan_rx_handler;
+    flexcan_handlers[1].flags |= ITRF_SHARED;
+
+    flexcan_handlers[2].it = flexcan1_rx_irq_nums[2];
+    flexcan_handlers[2].data = (void*)flexcan_privs[1];
+    flexcan_handlers[2].handler = flexcan_rx_handler;
+    flexcan_handlers[2].flags |= (ITRF_SHARED);
+    flexcan_handlers[3].it = flexcan1_rx_irq_nums[3];
+    flexcan_handlers[3].data = (void*)flexcan_privs[1];;
+    flexcan_handlers[3].handler = flexcan_rx_handler;
+    flexcan_handlers[3].flags |= ITRF_SHARED;
+
+    itr_add(&flexcan_handlers[0]);
+    itr_add(&flexcan_handlers[1]);
+    itr_add(&flexcan_handlers[2]);
+    itr_add(&flexcan_handlers[3]);
+    itr_enable(flexcan_handlers[0].it);
+    itr_enable(flexcan_handlers[1].it);
+    itr_enable(flexcan_handlers[2].it);
+    itr_enable(flexcan_handlers[3].it);
+    
+    memset((void*)&local_tx_rings, 0, sizeof(local_tx_rings));
+    memset((void*)&local_rx_rings, 0, sizeof(local_rx_rings));
+    return 0;
+}
+
+early_init(flexcan_driver_init);
\ No newline at end of file
diff --git a/core/drivers/sorhta/include/ethernet.h b/core/drivers/sorhta/include/ethernet.h
new file mode 100644
index 000000000..b5e631a44
--- /dev/null
+++ b/core/drivers/sorhta/include/ethernet.h
@@ -0,0 +1,10 @@
+#ifndef __SORHTA_ETHERNET_H
+#define __SORHTA_ETHERNET_H
+#include <stdint.h>
+
+void pfe_add_tx_ring(uint32_t, uintptr_t);
+void pfe_add_rx_ring(uint32_t, uintptr_t);
+
+void rs_driver_init(void);
+
+#endif // !__SORHTA_ETHERNET_H
diff --git a/core/drivers/sorhta/include/flexcan-buffers.h b/core/drivers/sorhta/include/flexcan-buffers.h
new file mode 100644
index 000000000..98230c597
--- /dev/null
+++ b/core/drivers/sorhta/include/flexcan-buffers.h
@@ -0,0 +1,70 @@
+#ifndef FLEXCAN_BUFFERS_H
+#define FLEXCAN_BUFFERS_H
+
+#define _GNU_SOURCE
+#include <stdint.h>
+#include <assert.h>
+#include <string.h>
+#include <tee_api_types.h>
+#include <types_ext.h>
+#include <kernel/spinlock.h>
+#include <trace.h>
+
+/* 
+ * Constants for hash map configuration 
+ */
+#define PID_MAP_SIZE           256U    /* Number of buckets in hash map */
+#define PID_MAP_MAX_ENTRIES    1024U   /* Maximum entries in the map */
+#define HASH_MULTIPLIER        31U     /* Prime number for hash function */
+
+/*
+ * Buffer allocation constants
+ */
+#define CAN_BUFFER_SIZE            4096U  /* 4KB per buffer */
+#define CAN_BUFFER_POOL_SIZE       (512 * 1024U)  /* 512KB total pool */
+#define MAX_CAN_BUFFERS            (CAN_BUFFER_POOL_SIZE / CAN_BUFFER_SIZE)
+
+#define BUFFER_POOL_BASE       0xE2010000
+#define BUFFER_POOL_SIZE       0x00FF0000
+#define SHADOW_BUFFER_SIZE	sizeof(struct canfd_frame)
+
+/**
+ * Similar struct kept in the NW Inner kernel space for 
+ * tracking allocated buffers.
+ * Need to free these to let the NW inner kernel know that the buffer is nolonger
+ * Needed and thus can be freed.
+ */
+struct secv_can_buffer_rec {
+    void* page; // NW inner kernel maps to this page.
+	void* buffer; // the pointer to the buffer base.
+	void* kernel_addr; // the kernel address base of this page.
+	uint64_t phys_addr;
+	uint64_t available; // tacks used frames
+};
+
+/*
+ * Linked list entry for hash bucket chaining
+ */
+typedef struct pid_buffer_entry {
+    uint32_t pid;                      /* Process ID */
+    uintptr_t buffer_addr;             /* Physical buffer address */
+    struct pid_buffer_entry *next;     /* Next entry in chain */
+} pid_buffer_entry_t;
+
+/*
+ * PID to buffer address hash map structure
+ */
+typedef struct pid_buffer_hashmap {
+    pid_buffer_entry_t *buckets[PID_MAP_SIZE];  /* Hash buckets */
+    uint32_t lock;                            /* Map access lock */
+    size_t count;                               /* Number of entries */
+    pid_buffer_entry_t entries[PID_MAP_MAX_ENTRIES]; /* Pre-allocated entries */
+    unsigned int free_entries_bitmap[PID_MAP_MAX_ENTRIES / 32]; /* Bitmap of free entries */
+} pid_buffer_hashmap_t;
+
+int can_secure_buffer_init(uintptr_t pool_base, size_t pool_size);
+uintptr_t can_secure_buffer_allocate(uint32_t pid);
+int can_secure_buffer_free(uint32_t pid);
+int can_free_message_buffer(void* message_addr);
+
+#endif
\ No newline at end of file
diff --git a/core/drivers/sorhta/include/flexcan.h b/core/drivers/sorhta/include/flexcan.h
new file mode 100644
index 000000000..54f84eb0a
--- /dev/null
+++ b/core/drivers/sorhta/include/flexcan.h
@@ -0,0 +1,346 @@
+#ifndef FLEXCAN_H
+#define FLEXCAN_H
+
+#define _GNU_SOURCE
+#include <stdint.h>
+#include <assert.h>
+#include <string.h>
+#include <io.h>
+#include <kernel/spinlock.h>
+#include <trace.h>
+#include <arm64.h>
+
+#include <tee_api_types.h>
+#include <types_ext.h>
+
+// Your shared memory structures
+#define NUM_FLEXCAN_INTERFACES      2
+#define RX_RING_SIZE                512
+#define FRAME_COUNT_PER_MB          16
+#define NUM_TX_BUFFERS              1
+#define NUM_RX_BUFFERS              FRAME_COUNT_PER_MB * NUM_TX_BUFFERS
+#define MAX_MBS                     128
+#define CAN_MAX_DLEN                8
+
+#define CAN_BUFFER_SIZE             4096UL
+
+#define FLEXCAN_MB_CODE_TX_INACTIVE	(0x8 << 24)
+#define FLEXCAN_MB_CODE_RX_BUSY_BIT	(0x1 << 24)
+#define FLEXCAN_MB_CNT_EDL          (0x1 << 31)
+
+#define BIT_ULL(nr)		(ULL(1) << (nr))
+
+/* CAN payload length and DLC definitions according to ISO 11898-1 */
+#define CAN_MAX_DLC 8
+#define CAN_MAX_RAW_DLC 15
+#define CAN_MAX_DLEN 8
+#define CANFD_MAX_DLEN 64
+
+#define FRAME_COUNT_PER_MB 16  // Adjust as needed (total ~9 KB of frame data)
+#define RING_TOTAL_SIZE (sizeof(struct ring_metadata) + FRAME_COUNT * FRAME_SIZE)
+#define MAX_MBS	128
+
+#define PAGE_SIZE                       0x1000UL
+#define S32_FLEXCAN0_BASE               (0x401B4000ul)
+#define S32_FLEXCAN1_BASE               (0x401BE000ul)
+#define SORHTA_MAIN_SHARED_DATA_OFF     (0)
+
+
+#define __bitwise   __attribute((bitwise))
+typedef uint32_t    __u32;
+typedef uint8_t   uint8_t;
+typedef __u32    __be32;
+typedef uint32_t canid_t;
+
+#define __struct_group(TAG, NAME, ATTRS, MEMBERS...) \
+	union { \
+		struct { MEMBERS } ATTRS; \
+		struct TAG { MEMBERS } ATTRS NAME; \
+	} ATTRS
+
+#define struct_group(NAME, MEMBERS...)	\
+__struct_group(/* no tag */, NAME, /* no attrs */, MEMBERS)
+
+typedef struct flexcan_mb {
+    uint32_t can_ctrl;
+    uint32_t can_id;
+    uint32_t data[];
+} flexcan_mb_t;
+
+static inline uint32_t __be32_to_cpu(const uintptr_t value)
+{
+    uintptr_t result = value;
+
+    // If the system is little-endian, swap the bytes to convert to native endianness
+    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+        result = ((result >> 24) & 0xFF) | ((result >> 8) & 0xFF00) |
+                 ((result << 8) & 0xFF0000) | ((result << 24) & 0xFF000000);
+    #endif
+
+    return result;
+}
+
+/* Structure of the hardware registers */
+typedef struct flexcan_regs {
+	uint32_t mcr;		/* 0x00 */
+	uint32_t ctrl;		/* 0x04 - Not affected by Soft Reset */
+	uint32_t timer;		/* 0x08 */
+	uint32_t tcr;		/* 0x0c */
+	uint32_t rxgmask;		/* 0x10 - Not affected by Soft Reset */
+	uint32_t rx14mask;		/* 0x14 - Not affected by Soft Reset */
+	uint32_t rx15mask;		/* 0x18 - Not affected by Soft Reset */
+	uint32_t ecr;		/* 0x1c */
+	uint32_t esr;		/* 0x20 */
+	uint32_t imask2;		/* 0x24 */
+	uint32_t imask1;		/* 0x28 */
+	uint32_t iflag2;		/* 0x2c */
+	uint32_t iflag1;		/* 0x30 */
+	union {			/* 0x34 */
+		uint32_t gfwr_mx28;	/* MX28, MX53 */
+		uint32_t ctrl2;	/* MX6, VF610 - Not affected by Soft Reset */
+	};
+	uint32_t esr2;		/* 0x38 */
+	uint32_t imeur;		/* 0x3c */
+	uint32_t lrfr;		/* 0x40 */
+	uint32_t crcr;		/* 0x44 */
+	uint32_t rxfgmask;		/* 0x48 */
+	uint32_t rxfir;		/* 0x4c - Not affected by Soft Reset */
+	uint32_t cbt;		/* 0x50 - Not affected by Soft Reset */
+	uint32_t _reserved2;		/* 0x54 */
+	uint32_t dbg1;		/* 0x58 */
+	uint32_t dbg2;		/* 0x5c */
+	uint32_t _reserved3[8];	/* 0x60 */
+	struct_group(init,
+		uint8_t mb[2][512];		/* 0x80 - Not affected by Soft Reset */
+		/* FIFO-mode:
+		 *			MB
+		 * 0x080...0x08f	0	RX message buffer
+		 * 0x090...0x0df	1-5	reserved
+		 * 0x0e0...0x0ff	6-7	8 entry ID table
+		 *				(mx25, mx28, mx35, mx53)
+		 * 0x0e0...0x2df	6-7..37	8..128 entry ID table
+		 *				size conf'ed via ctrl2::RFFN
+		 *				(mx6, vf610)
+		 */
+		uint32_t _reserved4[256];	/* 0x480 */
+		uint32_t rximr[64];		/* 0x880 - Not affected by Soft Reset */
+		uint32_t _reserved5[24];	/* 0x980 */
+		uint32_t gfwr_mx6;		/* 0x9e0 - MX6 */
+		uint32_t _reserved6[39];	/* 0x9e4 */
+		uint32_t _rxfir[6];		/* 0xa80 */
+		uint32_t _reserved8[2];	/* 0xa98 */
+		uint32_t _rxmgmask;		/* 0xaa0 */
+		uint32_t _rxfgmask;		/* 0xaa4 */
+		uint32_t _rx14mask;		/* 0xaa8 */
+		uint32_t _rx15mask;		/* 0xaac */
+		uint32_t tx_smb[4];		/* 0xab0 */
+		uint32_t rx_smb0[4];		/* 0xac0 */
+		uint32_t rx_smb1[4];		/* 0xad0 */
+	);
+	uint32_t mecr;		/* 0xae0 */
+	uint32_t erriar;		/* 0xae4 */
+	uint32_t erridpr;		/* 0xae8 */
+	uint32_t errippr;		/* 0xaec */
+	uint32_t rerrar;		/* 0xaf0 */
+	uint32_t rerrdr;		/* 0xaf4 */
+	uint32_t rerrsynr;		/* 0xaf8 */
+	uint32_t errsr;		/* 0xafc */
+	uint32_t _reserved7[64];	/* 0xb00 */
+	uint32_t fdctrl;		/* 0xc00 - Not affected by Soft Reset */
+	uint32_t fdcbt;		/* 0xc04 - Not affected by Soft Reset */
+	uint32_t fdcrc;		/* 0xc08 */
+	uint32_t _reserved9[199];	/* 0xc0c */
+	struct_group(init_fd,
+		uint32_t tx_smb_fd[18];	/* 0xf28 */
+		uint32_t rx_smb0_fd[18];	/* 0xf70 */
+		uint32_t rx_smb1_fd[18];	/* 0xfb8 */
+	);
+} flexcan_regs_t;
+
+
+static inline uint32_t upper_32_bits(uint64_t num)
+{
+	return (uint32_t)(num >> 32);
+}
+
+static inline uint32_t lower_32_bits(uint64_t num)
+{
+	return (uint32_t)(num & 0xFFFFFFFF);
+}
+
+typedef struct canfd_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	uint8_t    len;     /* frame payload length in byte */
+	uint8_t    flags;   /* additional flags for CAN FD */
+	uint8_t    __res0;  /* reserved / padding */
+	uint8_t    __res1;  /* reserved / padding */
+	uint8_t    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
+} canfd_frame_t;
+
+/**
+ * SECV: this is the reduced state, for device control. shared between the inner kernel & SW driverlet.
+ * For security, this MUST be stored in the inner kernel region at the NW end.
+ * OK to be read by outer kernel, risky to be written by outer kernel as a compromised 
+ * outer kernel can use it to control the SW driverlet instead.
+ */
+struct flexcan_priv {
+	struct flexcan_regs *regs;
+	struct flexcan_mb *tx_mb;
+	struct flexcan_mb *tx_mb_reserved;
+    uint8_t interface_idx;
+    uint8_t nsec_initialized;
+    uint8_t sec_initialized;
+	uint8_t tx_mb_idx;
+	uint8_t mb_count;
+    uint8_t mb_size;
+    uint64_t rx_mask;
+    uint64_t tx_mask;
+    uint32_t reg_ctrl_default;
+    uint32_t quirks;
+    uint32_t offload_mb_first;
+    uint32_t offload_mb_last;
+	uint64_t interrupts_bitmap;
+};
+
+struct rx_mb {
+    uint32_t can_ctrl;
+    uint32_t can_id;
+    struct canfd_frame data;
+};
+
+struct tx_mb {
+    uint32_t can_ctrl;
+    uint32_t can_ctrl_tx;
+    uint32_t can_id;
+    struct canfd_frame *data;
+};
+
+struct secv_tx_ring_buffers {
+    struct tx_mb mbs[NUM_TX_BUFFERS];
+    size_t count;
+};
+
+struct secv_rx_ring_buffers {
+    struct rx_mb mbs[NUM_RX_BUFFERS];
+    size_t count;
+};
+
+#define SORHTA_PRIV0_BASE_OFF           (PAGE_SIZE)
+#define SORHTA_PRIV1_BASE_OFF           (PAGE_SIZE * 2)
+#define SORHTA_FLEXCAN_RX_SHMEM_BASE0_OFF	(PAGE_SIZE * 3)
+#define SORHTA_FLEXCAN_RX_SHMEM_SIZE0	    ((sizeof(struct secv_rx_ring_buffers) + PAGE_SIZE-1) & ~((size_t)0xFFF))
+#define SORHTA_FLEXCAN_RX_SHMEM_BASE1_OFF	(SORHTA_FLEXCAN_RX_SHMEM_BASE0_OFF + SORHTA_FLEXCAN_RX_SHMEM_SIZE0)
+#define SORHTA_FLEXCAN_RX_SHMEM_SIZE1	    (SORHTA_FLEXCAN_RX_SHMEM_SIZE0)
+
+#define SORHTA_FLEXCAN_TX_SHMEM_BASE0_OFF	(SORHTA_FLEXCAN_RX_SHMEM_BASE1_OFF + SORHTA_FLEXCAN_RX_SHMEM_SIZE1)
+#define SORHTA_FLEXCAN_TX_SHMEM_SIZE0	    ((sizeof(struct secv_tx_ring_buffers) + PAGE_SIZE-1) & ~((size_t)0xFFF))
+#define SORHTA_FLEXCAN_TX_SHMEM_BASE1_OFF	(SORHTA_FLEXCAN_TX_SHMEM_BASE0_OFF + SORHTA_FLEXCAN_TX_SHMEM_SIZE0)
+#define SORHTA_FLEXCAN_TX_SHMEM_SIZE1	    (SORHTA_FLEXCAN_TX_SHMEM_SIZE0)
+#define SORHTA_SHMEM_BASE					0xE0000000UL
+
+
+static inline uint32_t swab32(uint32_t x)
+{
+	return  ((x & (uint32_t)0x000000ffUL) << 24) |
+		((x & (uint32_t)0x0000ff00UL) <<  8) |
+		((x & (uint32_t)0x00ff0000UL) >>  8) |
+		((x & (uint32_t)0xff000000UL) >> 24);
+}
+
+static inline uint32_t swab32p(void *p)
+{
+	uint32_t *q = (uint32_t*)p;
+
+	return swab32(*q);
+}
+
+#define get_le32(p) (*((uint32_t *) (p)))
+#define cpu_to_be32(x) swab32(x)
+
+static inline uint32_t be32_to_cpup(const uint32_t *p)
+{
+	return swab32p((uint32_t *)p);
+}
+
+static inline uint64_t flexcan_read64_mask(struct flexcan_priv* priv, volatile void* addr, uint64_t mask)
+{
+	uint64_t reg = 0;
+	if(upper_32_bits(mask))
+	{
+		reg = (uint64_t)io_read32((uintptr_t)((char*)addr - 4)) << 32;
+	}
+	if(lower_32_bits(mask))
+	{
+		reg |= (uint64_t)io_read32((uintptr_t)addr);
+	}
+
+	return reg & mask;
+}
+
+static inline void flexcan_write64(struct flexcan_priv* priv, uint64_t val, volatile void* addr)
+{
+	if(upper_32_bits(val))
+	{
+		io_write32((uintptr_t)((char*)addr - 4), upper_32_bits(val));
+	}
+	if(lower_32_bits(val))
+	{
+		io_write32((uintptr_t)((char*)addr), lower_32_bits(val));
+	}
+}
+
+
+static struct flexcan_mb *flexcan_get_mb(const struct flexcan_priv *priv,uint8_t mb_index)
+{
+    uint8_t bank_size;
+    bool bank;
+
+    bank_size = sizeof(priv->regs->mb[0]) / priv->mb_size;
+
+    bank = mb_index >= bank_size;
+    if (bank)
+    	mb_index -= bank_size;
+
+    return (struct flexcan_mb*)
+    (&priv->regs->mb[bank][priv->mb_size * mb_index]);
+}
+
+/* CAN DLC to real data length conversion helpers */
+
+static const uint8_t dlc2len[] = {
+	0, 1, 2, 3, 4, 5, 6, 7,
+	8, 12, 16, 20, 24, 32, 48, 64
+};
+
+/* get data length from raw data length code (DLC) */
+static uint8_t can_fd_dlc2len(uint8_t dlc)
+{
+	return dlc2len[dlc & 0x0F];
+}
+#define min_t(type, x, y) \
+    ({ type __min1 = (x); type __min2 = (y); __min1 < __min2 ? __min1 : __min2; })
+#define can_cc_dlc2len(dlc)	(min_t(unsigned char, (dlc), CAN_MAX_DLEN))
+
+static inline uint64_t flexcan_read_reg_iflag_rx(struct flexcan_priv *priv)
+{
+    return flexcan_read64_mask(priv, &priv->regs->iflag1, priv->rx_mask);
+}
+
+static inline uint64_t flexcan_read_reg_iflag_tx(struct flexcan_priv *priv)
+{
+    return flexcan_read64_mask(priv, &priv->regs->iflag1, priv->tx_mask);
+}
+
+
+void flexcan_rs_driver_init(uint8_t *virtual_memory);
+void flexcan_rs_handle_tx(uint32_t interface_index);
+void flexcan_rs_handle_rx(uint32_t interface_index);
+void flexcan_rs_can_secure_buffer_free(uint32_t pid);
+size_t flexcan_rs_can_secure_buffer_allocate(uint32_t pid);
+
+TEE_Result handle_flexcan_tx_smc(uint32_t interface_index);
+TEE_Result handle_flexcan_rx_smc(uint32_t interface_index);
+TEE_Result handle_flexcan_secure_can_buffer_allocate(uint32_t pid, uintptr_t* addr);
+TEE_Result handle_flexcan_secure_can_buffer_free(uint32_t pid);
+
+#endif
\ No newline at end of file
diff --git a/core/drivers/sorhta/sub.mk b/core/drivers/sorhta/sub.mk
new file mode 100644
index 000000000..25ffec31b
--- /dev/null
+++ b/core/drivers/sorhta/sub.mk
@@ -0,0 +1,41 @@
+# export CARGO_BUILD_TARGET="aarch64-unknown-linux-gnu"
+# export RUSTC_TARGET="aarch64-unknown-linux-gnu"
+# export CARGO_HOME="${HOME}/.cargo/bin/"
+# LIB=sorhta_rs
+# CARGO=${HOME}/.cargo/bin/cargo
+# CURRENT_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
+# TARGET=aarch64-unknown-linux-gnu
+# TARGET_DIR=${CURRENT_DIR}${LIB}/target/
+# CARGO_TARGET_DIR=${TARGET_DIR}/${TARGET}/release
+# RUST_LIB=${CARGO_TARGET_DIR}/lib${LIB}.a
+# OUT_DIR=$(out-dir)
+
+# RUSTFLAGS="-C target-feature=+crt-static -C embed-bitcode=yes"
+# #CARGO_TARGET_DIR=${TARGET_DIR}
+
+# .PHONY: ${RUST_LIB}
+
+# all: ${RUST_LIB}
+
+# ${RUST_LIB}: 
+# 	@echo "DEBUG: CARGO_BUILD_TARGET=${CARGO_BUILD_TARGET}"
+# 	@echo "DEBUG: RUSTC_TARGET=${RUSTC_TARGET}" 
+# 	@echo "DEBUG: TARGET=${TARGET}"
+# 	@echo "DEBUG: Checking rustc target list:"
+# 	@echo "${HOME}"
+# 	@which rustc
+# 	@${HOME}/.cargo/bin/rustc --print target-list | grep aarch64 || echo "aarch64 targets not found"
+# 	#RUSTFLAGS=${RUSTFLAGS} CARGO_TARGET_DIR=${TARGET_DIR} RUSTC=${HOME}/.cargo/bin/rustc \
+# 	#${CARGO} build --release \
+# 	#	--target aarch64-unknown-linux-gnu	\
+#   #		--manifest-path ${CURRENT_DIR}${LIB}/Cargo.toml 
+# 	cp ${RUST_LIB} ${OUT_DIR}/.
+
+
+global-incdirs-y 		+= include
+srcs-y 					+= flexcan.c
+srcs-y					+= ethernet.c
+srcs-y					+= flexcan-buffers.c 
+
+
+cflags-y += -DCFG_SORHTA_DRIVER=1
diff --git a/core/drivers/sub.mk b/core/drivers/sub.mk
index a380a8b58..00f226695 100644
--- a/core/drivers/sub.mk
+++ b/core/drivers/sub.mk
@@ -92,3 +92,4 @@ subdirs-y += imx
 subdirs-y += pm
 subdirs-y += wdt
 subdirs-y += rtc
+subdirs-y += sorhta
\ No newline at end of file
diff --git a/core/lib/libsorhta/include/sorhta.h b/core/lib/libsorhta/include/sorhta.h
new file mode 100644
index 000000000..f4ffe6387
--- /dev/null
+++ b/core/lib/libsorhta/include/sorhta.h
@@ -0,0 +1,90 @@
+#ifndef __SOR_HTA_H
+#define __SOR_HTA_H
+
+#include <sm/sm.h>
+#include <kernel/spinlock.h>
+#include <io.h>
+#include <sm/optee_smc.h>
+#include <kernel/thread_arch.h>
+#include <tee_api_types.h>
+#include <trace.h>
+
+#define SOR_HTA_FUNC_ID_MASK 0xFF
+
+#define SECV_FLEXCAN_NOTIF_ID 			0x0
+#define SECV_BITS_PER_MEDIA_FLEXCAN		0x2 //send and receive
+#define SECV_SEND_COMPLETE_BIT_IDX		0x0
+#define SECV_RECV_BIT_IDX				0x1
+#define SECV_FLEXCAN_SGI_NUM			0x7
+
+TEE_Result handle_flexcan_tx_smc(uint32_t interface_index);
+TEE_Result handle_flexcan_rx_smc(uint32_t interface_index);
+TEE_Result handle_flexcan_secure_can_buffer_allocate(uint32_t pid, uintptr_t* addr);
+TEE_Result handle_flexcan_secure_can_buffer_free(uint32_t pid);
+
+void sor_hta_handle_io_read_le(struct thread_smc_args *args);
+void sor_hta_handle_io_read_be(struct thread_smc_args *args);
+void sor_hta_handle_io_write_le(struct thread_smc_args *args);
+void sor_hta_handle_io_write_be(struct thread_smc_args *args);
+void sor_can_send_frame(struct thread_smc_args *args);
+void sor_can_recv_frame(struct thread_smc_args *args);
+void sor_can_alloc_buffer(struct thread_smc_args *args);
+void sor_can_free_buffer(struct thread_smc_args *args);
+
+void sor_eth_notify(struct thread_smc_args *args);
+void sor_eth_add_tx_ring(struct thread_smc_args *args);
+void sor_eth_add_rx_ring(struct thread_smc_args *args);
+
+static void handle_sor_hta_request(struct thread_smc_args *args)
+{
+	uint32_t func = args->a0 & SOR_HTA_FUNC_ID_MASK;
+	//EMSG("Got a call for SORHTA %x", func);
+	switch (func) {
+	case OPTEE_FUNCID_READ_BE:
+		sor_hta_handle_io_read_be(args);
+		break;
+	case OPTEE_FUNCID_READ_LE:
+		//EMSG("Handling read le");
+		sor_hta_handle_io_read_le(args);
+		break;
+	case OPTEE_FUNCID_WRITE_BE:
+		sor_hta_handle_io_write_be(args);
+		break;
+	case OPTEE_FUNCID_WRITE_LE:
+		//EMSG("Handling Write le");
+		sor_hta_handle_io_write_le(args);
+		break;
+	case OPTEE_FUNCID_CAN_NOTIFY:
+		args->a0 = OPTEE_SMC_RETURN_OK;
+		break;
+	case OPTEE_FUNCID_XMIT:
+		//EMSG("Handling Xmit");
+		sor_can_send_frame(args);
+		break;
+	case OPTEE_FUNCID_RECV:
+		sor_can_recv_frame(args);
+		break;
+	case OPTEE_FUNCID_ETH_XMIT:
+	case OPTEE_FUNCID_ETH_RECV:
+		sor_eth_notify(args);
+		break;
+    case OPTEE_FUNCID_PFE_ADD_RX:
+        sor_eth_add_rx_ring(args);
+        break;
+    case OPTEE_FUNCID_PFE_ADD_TX:
+        sor_eth_add_tx_ring(args);
+        break;
+	case OPTEE_FUNCID_CAN_ALLOCATE_BUFFER:
+		//EMSG("Handling buffer alloc request");
+		sor_can_alloc_buffer(args);
+		break;
+	case OPTEE_FUNCID_CAN_FREE_BUFFER:
+		sor_can_free_buffer(args);
+		break;
+	default:
+		break;
+	}
+	args->a0 = OPTEE_SMC_RETURN_OK;
+}
+
+#endif
diff --git a/core/lib/libsorhta/mem.c b/core/lib/libsorhta/mem.c
new file mode 100644
index 000000000..645002740
--- /dev/null
+++ b/core/lib/libsorhta/mem.c
@@ -0,0 +1,62 @@
+#include <sorhta.h>
+#include <mm/core_memprot.h>
+
+static unsigned int mu_spinlock = SPINLOCK_UNLOCK;
+
+void sor_hta_handle_io_read_le(struct thread_smc_args *args)
+{
+    cpu_spin_lock(&mu_spinlock);
+    {
+        paddr_t phy_addr = (paddr_t)args->a1;
+        vaddr_t address = phys_to_virt(phy_addr, MEM_AREA_IO_SEC, 1);
+        uint32_t val = io_read32(address);
+        args->a1 = val;
+    }
+    cpu_spin_unlock(&mu_spinlock);
+}
+
+void sor_hta_handle_io_read_be(struct thread_smc_args *args)
+{
+    cpu_spin_lock(&mu_spinlock);
+    {
+        paddr_t phy_addr = (paddr_t)args->a1;
+        vaddr_t address = phys_to_virt(phy_addr, MEM_AREA_IO_SEC, 1);
+        uint32_t val = get_be32((const void*)address);
+        args->a1 = val;
+    }
+    cpu_spin_unlock(&mu_spinlock);
+}
+
+void sor_hta_handle_io_write_le(struct thread_smc_args *args)
+{
+    cpu_spin_lock(&mu_spinlock);
+    {
+        paddr_t phy_addr = (paddr_t)args->a1;
+        vaddr_t address = phys_to_virt(phy_addr, MEM_AREA_IO_SEC, 1);
+        uint32_t val = args->a2;
+        io_write32(address, val);
+    }
+    cpu_spin_unlock(&mu_spinlock);
+}
+
+void sor_hta_handle_io_write_be(struct thread_smc_args *args)
+{
+    cpu_spin_lock(&mu_spinlock);
+    {
+        paddr_t phy_addr = (paddr_t)args->a1;
+        vaddr_t address = phys_to_virt(phy_addr, MEM_AREA_IO_SEC, 1);
+        uint32_t val = args->a2;
+        put_be32((void*)address, val);
+    }
+    cpu_spin_unlock(&mu_spinlock);
+}
+
+void sor_hta_handle_can_send(struct thread_smc_args *args)
+{
+    cpu_spin_lock(&mu_spinlock);
+    {
+        paddr_t phy_addr = (paddr_t)args->a1;
+
+    }
+    cpu_spin_unlock(&mu_spinlock);
+}
\ No newline at end of file
diff --git a/core/lib/libsorhta/sub.mk b/core/lib/libsorhta/sub.mk
new file mode 100644
index 000000000..911c9d05c
--- /dev/null
+++ b/core/lib/libsorhta/sub.mk
@@ -0,0 +1,6 @@
+global-incdirs-y += include
+srcs-y += mem.c
+
+cflags-y += -DCFG_LIBSORHTA=1
+
+$(call force, CFG_SORHTA_DRIVER, y)
\ No newline at end of file
diff --git a/core/mm/core_mmu.c b/core/mm/core_mmu.c
index 584ff78e0..5d3d8cc43 100644
--- a/core/mm/core_mmu.c
+++ b/core/mm/core_mmu.c
@@ -82,6 +82,7 @@ static struct memaccess_area nsec_shared[] __nex_data = {
 #ifdef CFG_CORE_RESERVED_SHM
 	MEMACCESS_AREA(TEE_SHMEM_START, TEE_SHMEM_SIZE),
 #endif
+	MEMACCESS_AREA(0xE0000000UL, 0x3000000ul),
 };
 
 #if defined(CFG_SECURE_DATA_PATH)
diff --git a/core/tee/entry_std.c b/core/tee/entry_std.c
index d3ae62486..a4a7adcbb 100644
--- a/core/tee/entry_std.c
+++ b/core/tee/entry_std.c
@@ -486,7 +486,6 @@ static void register_shm(struct optee_msg_arg *arg, uint32_t num_params)
 	struct mobj *mobj = NULL;
 
 	arg->ret = TEE_ERROR_BAD_PARAMETERS;
-
 	if (num_params != 1 ||
 	    (arg->params[0].attr !=
 	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
diff --git a/ta/secv_can_ids/Makefile b/ta/secv_can_ids/Makefile
new file mode 100644
index 000000000..8bd919070
--- /dev/null
+++ b/ta/secv_can_ids/Makefile
@@ -0,0 +1,3 @@
+TA_DEV_KIT_DIR ?= $(TA_DEV_KIT_DIR)
+
+-include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
\ No newline at end of file
diff --git a/ta/secv_can_ids/ta.c b/ta/secv_can_ids/ta.c
new file mode 100644
index 000000000..430d3639a
--- /dev/null
+++ b/ta/secv_can_ids/ta.c
@@ -0,0 +1,56 @@
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include "ta.h"
+
+#define MAX_CAN_ID_BLOB_SIZE    4096
+
+static uint8_t can_id_blob[MAX_CAN_ID_BLOB_SIZE];
+static size_t can_id_blob_size = 0;
+
+TEE_Result TA_CreateEntryPoint(void)
+{
+    return TEE_SUCCESS;
+}
+
+void TA_DestroyEntryPoint(void)
+{
+    ;;
+}
+
+TEE_Result TA_OpenSessionEntryPoint(uint32_t param_types, TEE_Param params[4], void **session_context)
+{
+    (void)param_types;
+    (void)params;
+    (void)session_context;
+    return TEE_SUCCESS;
+}
+
+void TA_ClosesSessionEntryPoint(void *session_context)
+{
+    (void)session_context;
+}
+
+TEE_Result TA_InvokeCommandEntryPoint(void *session_context, uint32_t cmd_id, uint32_t param_types, TEE_Param params[4])
+{
+    (void)session_context;
+
+    switch(cmd_id)
+    {
+        case CMD_STORE_CAN_ID_BLOB:
+            if(param_types != TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_INPUT, TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE, TEE_PARAM_TYPE_NONE)) {
+                return TEE_ERROR_BAD_PARAMETERS;
+            }
+
+            if(params[0].memref.size > MAX_CAN_ID_BLOB_SIZE) {
+                return TEE_ERROR_BAD_PARAMETERS;
+            }
+
+            TEE_MemMove(can_id_blob, params[0].memref.buffer, params[0].memref.size);
+            can_id_blob_size = params[0].memref.size;
+
+            return TEE_SUCCESS;
+        
+        default:
+            return TEE_ERROR_NOT_SUPPORTED;
+    }
+}
\ No newline at end of file
diff --git a/ta/secv_can_ids/ta.h b/ta/secv_can_ids/ta.h
new file mode 100644
index 000000000..4c6cd50f2
--- /dev/null
+++ b/ta/secv_can_ids/ta.h
@@ -0,0 +1,6 @@
+#ifndef TA_CAN_ID_TA_H
+#define TA_CAN_ID_TA_H
+
+#define CMD_STORE_CAN_ID_BLOB   0
+
+#endif
\ No newline at end of file
diff --git a/ta/secv_can_ids/user_ta_header_defines.h b/ta/secv_can_ids/user_ta_header_defines.h
new file mode 100644
index 000000000..6a07aac0f
--- /dev/null
+++ b/ta/secv_can_ids/user_ta_header_defines.h
@@ -0,0 +1,18 @@
+#ifndef USER_TA_HEADER_DEFINES_H
+#define USER_TA_HEADER_DEFINES_H
+
+#include <uuid/uuid.h>
+
+/* Define the SECV CAN ID TA's UUID*/
+#define TA_UUID { 0x12345678, 0x9abc, 0xdef0, \
+                    { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 } }
+
+/* Flags */
+#define TA_FLAGS (TA_FLAG_SINGLE_INSTANCE | TA_FLAG_INSTANCE_KEEP_ALIVE)
+
+#define TA_STACK_SIZE   (2 * 1024)
+#define TA_DATA_SIZE    (32 * 1024)
+
+
+
+#endif
\ No newline at end of file
